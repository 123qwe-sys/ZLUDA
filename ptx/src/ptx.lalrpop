use std::str::FromStr;
use super::ast;

grammar;

match {
    r"\s+" => { },
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },
    r"sm_[0-9]+" => ShaderModel,
    r"-?[?:0x]?[0-9]+" => Num
} else {
    r"(?:[a-zA-Z][a-zA-Z0-9_$]*|[_$%][a-zA-Z0-9_$]+)<[0-9]+>" => ParametrizedID,
} else {
    _
}

pub Module: () = {
    Version
    Target
    Directive*
};

Version = {
    ".version" VersionNumber
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#ptx-module-directives-target
Target = {
    ".target" Comma<TargetSpecifier>
};

TargetSpecifier = {
    ShaderModel,
    "texmode_unified",
    "texmode_independent",
    "debug",
    "map_f64_to_f32"
};

Directive : () = {
    AddressSize,
    Function,
    File,
    Section
};

AddressSize = {
    ".address_size" Num
};

Function: (bool, &'input str) = {
    LinkingDirective* <is:IsKernel> <id:ID> "(" Comma<FunctionInput> ")" FunctionBody => (is, id)
};

LinkingDirective = {
    ".extern",
    ".visible",
    ".weak"
};

IsKernel: bool = {
    ".entry" => true,
    ".func" => false
};

FunctionInput = {
    ".param" Type ID
};

FunctionBody = {
    "{" Statement* "}"
};

StateSpaceSpecifier = {
    ".reg",
    ".sreg",
    ".const",
    ".global",
    ".local",
    ".shared"
};

Type = {
    BaseType,
    ".pred",
    ".f16",
    ".f16x2", 
};

BaseType = {
    ".b8", ".b16", ".b32", ".b64",
    ".u8", ".u16", ".u32", ".u64",
    ".s8", ".s16", ".s32", ".s64",
    ".f32", ".f64"
};

Statement: () = {
    Label,
    DebugDirective,
    Variable ";",
    Instruction ";"
};

DebugDirective = {
    DebugLocation
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#debugging-directives-loc
DebugLocation = {
    ".loc" Num Num Num
};

Label = {
    ID ":"
};

Variable = {
    StateSpaceSpecifier Type VariableName
};

VariableName = {
    ID,
    ParametrizedID
};

Instruction: () = {
    InstLd,
    InstMov,
    InstMul,
    InstAdd,
    InstSetp,
    InstNot,
    InstBra,
    InstCvt,
    InstShl,
    InstSt,
    InstRet,
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-ld
InstLd = {
    "ld" LdQualifier? LdStateSpace? LdCacheOperator? Vector? BaseType ID "," "[" ID "]"
};

LdQualifier: () = {
    ".weak",
    ".volatile",
    ".relaxed" LdScope,
    ".acquire" LdScope,
};

LdScope = {
    ".cta", ".gpu", ".sys"
};

LdStateSpace = {
    ".const",
    ".global",
    ".local",
    ".param",
    ".shared",
};

LdCacheOperator = {
    ".ca",
    ".cg",
    ".cs",
    ".lu",
    ".cv",
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-mov
InstMov = {
    "mov" MovType ID "," Operand
};

MovType = {
    ".b16", ".b32", ".b64",
    ".u16", ".u32", ".u64",
    ".s16", ".s32", ".s64",
    ".f32", ".f64",
    ".pred"
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#integer-arithmetic-instructions-mul
// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#floating-point-instructions-mul
// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#half-precision-floating-point-instructions-mul
InstMul: () = {
    "mul" MulIntControl? IntType ID "," Operand "," Operand,
    "mul" RoundingMode? ".ftz"? ".sat"? ".f32" ID "," Operand "," Operand,
    "mul" RoundingMode? ".f64" ID "," Operand "," Operand,
    "mul" ".rn"? ".ftz"? ".sat"? ".f16" ID "," Operand "," Operand,
    "mul" ".rn"? ".ftz"? ".sat"? ".f16x2" ID "," Operand "," Operand,
};

MulIntControl = {
    "hi", ".lo", ".wide"
};

#[inline]
RoundingMode = {
    ".rn", ".rz", ".rm", ".rp"
};

IntType = {
    ".u16", ".u32", ".u64",
    ".s16", ".s32", ".s64",
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#integer-arithmetic-instructions-add
// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#floating-point-instructions-add
// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#half-precision-floating-point-instructions-add
InstAdd: () = {
    "add" IntType ID "," Operand "," Operand,
    "add" ".sat" ".s32" ID "," Operand "," Operand,
    "add" RoundingMode? ".ftz"? ".sat"? ".f32" ID "," Operand "," Operand,
    "add" RoundingMode? ".f64" ID "," Operand "," Operand,
    "add" ".rn"? ".ftz"? ".sat"? ".f16" ID "," Operand "," Operand,
    "add" ".rn"? ".ftz"? ".sat"? ".f16x2" ID "," Operand "," Operand,
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#comparison-and-selection-instructions-setp
InstSetp: () = {
    "setp" SetpCmpOp ".ftz"? SetpType ID ("|" ID)? "," Operand "," Operand,
    "setp" SetpCmpOp SetpBoolOp ".ftz"? SetpType ID ("|" ID)? "," Operand "," Operand "," "!"? ID
};

SetpCmpOp = {
    ".eq", ".ne", ".lt", ".le", ".gt", ".ge", ".lo", ".ls", ".hi", ".hs",
    ".equ", ".neu", ".ltu", ".leu", ".gtu", ".geu", ".num", ".nan"
};

SetpBoolOp = {
    ".and", ".or", ".xor"
};

SetpType = {
    ".b16", ".b32", ".b64",
    ".u16", ".u32", ".u64",
    ".s16", ".s32", ".s64",
    ".f32", ".f64"
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#logic-and-shift-instructions-not
InstNot: () = {
    "not" NotType ID "," Operand
};

NotType = {
    ".pred", ".b16", ".b32", ".b64"
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#control-flow-instructions-at
InstAt = {
    "@" "!"? ID
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#control-flow-instructions-bra
InstBra = {
    InstAt? "bra" ".uni"? ID
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cvt
InstCvt = {
    "cvt" CvtRnd? ".ftz"? ".sat"? CvtType CvtType ID "," Operand
};

CvtRnd = {
    CvtIrnd,
    CvtFrnd
}

CvtIrnd = {
    ".rni", ".rzi", ".rmi", ".rpi"
};

CvtFrnd = {
    ".rn",  ".rz",  ".rm", ".rp"
};

CvtType = {
    ".u8", ".u16", ".u32", ".u64",
    ".s8", ".s16", ".s32", ".s64",
    ".f16", ".f32", ".f64"
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#logic-and-shift-instructions-shl
InstShl = {
    "shl" ShlType ID "," Operand "," Operand
};

ShlType = {
    ".b16", ".b32", ".b64"
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-st
InstSt = {
    "st" LdQualifier? StStateSpace? StCacheOperator? Vector? BaseType "[" ID "]" "," Operand
};

StStateSpace = {
    ".global",
    ".local",
    ".param",
    ".shared",
};

StCacheOperator = {
    ".wb",
    ".cg",
    ".cs",
    ".wt",
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#control-flow-instructions-ret
InstRet: () = {
    "ret" ".uni"?
};

Operand: () = {
    ID,
    Num,
    OffsetOperand,
    ArrayOperand,
    VectorOperand,
};

OffsetOperand = {
    ID "+" Num,
};

ArrayOperand = {
    ID "[" Num "]",
};

VectorOperand: () = {
    ID "." ID,
    ID DotID,
};

Vector = {
    ".v2",
    ".v4"
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#debugging-directives-file
File = {
    ".file" Num String ("," Num "," Num)?
};

// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#debugging-directives-section
Section = {
    ".section" DotID "{" SectionDwarfLines* "}"
};

SectionDwarfLines: () = {
    BitType Comma<Num>,
    ".b32" SectionLabel,
    ".b64" SectionLabel,
    ".b32" SectionLabel "+" Num,
    ".b64" SectionLabel "+" Num,
};

SectionLabel = {
    ID,
    DotID
};

BitType = {
    ".b8", ".b16", ".b32", ".b64"
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

String = r#""[^"]*""#;
VersionNumber = r"[0-9]+\.[0-9]+";
//Num: i128 = <s:r"[?:0x][0-9]+"> => i128::from_str(s).unwrap();
// https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#identifiers
ID: &'input str = <s:r"[a-zA-Z][a-zA-Z0-9_$]*|[_$%][a-zA-Z0-9_$]+"> => s;
DotID: &'input str = <s:r"\.[a-zA-Z][a-zA-Z0-9_$]*"> => s;