/* automatically generated by rust-bindgen */

#[doc = ""]
#[doc = " @brief compiler-independent type"]
pub type ze_bool_t = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of a driver instance"]
pub type ze_driver_handle_t = *mut _ze_driver_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's device object"]
pub type ze_device_handle_t = *mut _ze_device_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's command queue object"]
pub type ze_command_queue_handle_t = *mut _ze_command_queue_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's command list object"]
pub type ze_command_list_handle_t = *mut _ze_command_list_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's fence object"]
pub type ze_fence_handle_t = *mut _ze_fence_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's event pool object"]
pub type ze_event_pool_handle_t = *mut _ze_event_pool_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's event object"]
pub type ze_event_handle_t = *mut _ze_event_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's image object"]
pub type ze_image_handle_t = *mut _ze_image_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's module object"]
pub type ze_module_handle_t = *mut _ze_module_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_build_log_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of module's build log object"]
pub type ze_module_build_log_handle_t = *mut _ze_module_build_log_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's kernel object"]
pub type ze_kernel_handle_t = *mut _ze_kernel_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_sampler_handle_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " @brief Handle of driver's sampler object"]
pub type ze_sampler_handle_t = *mut _ze_sampler_handle_t;
#[doc = ""]
#[doc = " @brief IPC handle to a memory allocation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_ipc_mem_handle_t {
    #[doc = "< Opaque data representing an IPC handle"]
    pub data: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout__ze_ipc_mem_handle_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_ipc_mem_handle_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_ipc_mem_handle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_ipc_mem_handle_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_ipc_mem_handle_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_ipc_mem_handle_t>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_ipc_mem_handle_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = ""]
#[doc = " @brief IPC handle to a memory allocation"]
pub type ze_ipc_mem_handle_t = _ze_ipc_mem_handle_t;
#[doc = ""]
#[doc = " @brief IPC handle to a event pool allocation"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_ipc_event_pool_handle_t {
    #[doc = "< Opaque data representing an IPC handle"]
    pub data: [::std::os::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout__ze_ipc_event_pool_handle_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_ipc_event_pool_handle_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_ipc_event_pool_handle_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_ipc_event_pool_handle_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_ipc_event_pool_handle_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_ipc_event_pool_handle_t>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_ipc_event_pool_handle_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = ""]
#[doc = " @brief IPC handle to a event pool allocation"]
pub type ze_ipc_event_pool_handle_t = _ze_ipc_event_pool_handle_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Defines Return/Error codes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
#[must_use]
pub enum _ze_result_t {
    #[doc = "< [Core] success"]
    ZE_RESULT_SUCCESS = 0,
    #[doc = "< [Core] synchronization primitive not signaled"]
    ZE_RESULT_NOT_READY = 1,
    #[doc = "< [Core] device hung, reset, was removed, or driver update occurred"]
    ZE_RESULT_ERROR_DEVICE_LOST = 1879048193,
    #[doc = "< [Core] insufficient host memory to satisfy call"]
    ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY = 1879048194,
    #[doc = "< [Core] insufficient device memory to satisfy call"]
    ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY = 1879048195,
    #[doc = "< [Core] error occurred when building module, see build log for details"]
    ZE_RESULT_ERROR_MODULE_BUILD_FAILURE = 1879048196,
    #[doc = "< [Tools] access denied due to permission level"]
    ZE_RESULT_ERROR_INSUFFICIENT_PERMISSIONS = 1879113728,
    #[doc = "< [Tools] resource already in use and simultaneous access not allowed"]
    ZE_RESULT_ERROR_NOT_AVAILABLE = 1879113729,
    #[doc = "< [Validation] driver is not initialized"]
    ZE_RESULT_ERROR_UNINITIALIZED = 2013265921,
    #[doc = "< [Validation] generic error code for unsupported versions"]
    ZE_RESULT_ERROR_UNSUPPORTED_VERSION = 2013265922,
    #[doc = "< [Validation] generic error code for unsupported features"]
    ZE_RESULT_ERROR_UNSUPPORTED_FEATURE = 2013265923,
    #[doc = "< [Validation] generic error code for invalid arguments"]
    ZE_RESULT_ERROR_INVALID_ARGUMENT = 2013265924,
    #[doc = "< [Validation] handle argument is not valid"]
    ZE_RESULT_ERROR_INVALID_NULL_HANDLE = 2013265925,
    #[doc = "< [Validation] object pointed to by handle still in-use by device"]
    ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE = 2013265926,
    #[doc = "< [Validation] pointer argument may not be nullptr"]
    ZE_RESULT_ERROR_INVALID_NULL_POINTER = 2013265927,
    #[doc = "< [Validation] size argument is invalid (e.g., must not be zero)"]
    ZE_RESULT_ERROR_INVALID_SIZE = 2013265928,
    #[doc = "< [Validation] size argument is not supported by the device (e.g., too"]
    #[doc = "< large)"]
    ZE_RESULT_ERROR_UNSUPPORTED_SIZE = 2013265929,
    #[doc = "< [Validation] alignment argument is not supported by the device (e.g.,"]
    #[doc = "< too small)"]
    ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT = 2013265930,
    #[doc = "< [Validation] synchronization object in invalid state"]
    ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT = 2013265931,
    #[doc = "< [Validation] enumerator argument is not valid"]
    ZE_RESULT_ERROR_INVALID_ENUMERATION = 2013265932,
    #[doc = "< [Validation] enumerator argument is not supported by the device"]
    ZE_RESULT_ERROR_UNSUPPORTED_ENUMERATION = 2013265933,
    #[doc = "< [Validation] image format is not supported by the device"]
    ZE_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT = 2013265934,
    #[doc = "< [Validation] native binary is not supported by the device"]
    ZE_RESULT_ERROR_INVALID_NATIVE_BINARY = 2013265935,
    #[doc = "< [Validation] global variable is not found in the module"]
    ZE_RESULT_ERROR_INVALID_GLOBAL_NAME = 2013265936,
    #[doc = "< [Validation] kernel name is not found in the module"]
    ZE_RESULT_ERROR_INVALID_KERNEL_NAME = 2013265937,
    #[doc = "< [Validation] function name is not found in the module"]
    ZE_RESULT_ERROR_INVALID_FUNCTION_NAME = 2013265938,
    #[doc = "< [Validation] group size dimension is not valid for the kernel or"]
    #[doc = "< device"]
    ZE_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION = 2013265939,
    #[doc = "< [Validation] global width dimension is not valid for the kernel or"]
    #[doc = "< device"]
    ZE_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION = 2013265940,
    #[doc = "< [Validation] kernel argument index is not valid for kernel"]
    ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX = 2013265941,
    #[doc = "< [Validation] kernel argument size does not match kernel"]
    ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE = 2013265942,
    #[doc = "< [Validation] value of kernel attribute is not valid for the kernel or"]
    #[doc = "< device"]
    ZE_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE = 2013265943,
    #[doc = "< [Validation] command list type does not match command queue type"]
    ZE_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE = 2013265944,
    #[doc = "< [Validation] copy operations do not support overlapping regions of"]
    #[doc = "< memory"]
    ZE_RESULT_ERROR_OVERLAPPING_REGIONS = 2013265945,
    #[doc = "< [Core] unknown or internal error"]
    ZE_RESULT_ERROR_UNKNOWN = 2147483647,
}
#[doc = ""]
#[doc = " @brief Defines Return/Error codes"]
pub use self::_ze_result_t as ze_result_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_uuid_t"]
pub type ze_driver_uuid_t = _ze_driver_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_properties_t"]
pub type ze_driver_properties_t = _ze_driver_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_driver_ipc_properties_t"]
pub type ze_driver_ipc_properties_t = _ze_driver_ipc_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_uuid_t"]
pub type ze_device_uuid_t = _ze_device_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_properties_t"]
pub type ze_device_properties_t = _ze_device_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_compute_properties_t"]
pub type ze_device_compute_properties_t = _ze_device_compute_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_native_kernel_uuid_t"]
pub type ze_native_kernel_uuid_t = _ze_native_kernel_uuid_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_kernel_properties_t"]
pub type ze_device_kernel_properties_t = _ze_device_kernel_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_memory_properties_t"]
pub type ze_device_memory_properties_t = _ze_device_memory_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_memory_access_properties_t"]
pub type ze_device_memory_access_properties_t = _ze_device_memory_access_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_cache_properties_t"]
pub type ze_device_cache_properties_t = _ze_device_cache_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_image_properties_t"]
pub type ze_device_image_properties_t = _ze_device_image_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_p2p_properties_t"]
pub type ze_device_p2p_properties_t = _ze_device_p2p_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_command_queue_desc_t"]
pub type ze_command_queue_desc_t = _ze_command_queue_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_command_list_desc_t"]
pub type ze_command_list_desc_t = _ze_command_list_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_format_desc_t"]
pub type ze_image_format_desc_t = _ze_image_format_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_desc_t"]
pub type ze_image_desc_t = _ze_image_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_properties_t"]
pub type ze_image_properties_t = _ze_image_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_module_constants_t"]
pub type ze_module_constants_t = _ze_module_constants_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_module_desc_t"]
pub type ze_module_desc_t = _ze_module_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_desc_t"]
pub type ze_kernel_desc_t = _ze_kernel_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_kernel_properties_t"]
pub type ze_kernel_properties_t = _ze_kernel_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_group_count_t"]
pub type ze_group_count_t = _ze_group_count_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_event_pool_desc_t"]
pub type ze_event_pool_desc_t = _ze_event_pool_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_event_desc_t"]
pub type ze_event_desc_t = _ze_event_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_sampler_desc_t"]
pub type ze_sampler_desc_t = _ze_sampler_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_device_mem_alloc_desc_t"]
pub type ze_device_mem_alloc_desc_t = _ze_device_mem_alloc_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_host_mem_alloc_desc_t"]
pub type ze_host_mem_alloc_desc_t = _ze_host_mem_alloc_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_memory_allocation_properties_t"]
pub type ze_memory_allocation_properties_t = _ze_memory_allocation_properties_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_fence_desc_t"]
pub type ze_fence_desc_t = _ze_fence_desc_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_copy_region_t"]
pub type ze_copy_region_t = _ze_copy_region_t;
#[doc = ""]
#[doc = " @brief Forward-declare ze_image_region_t"]
pub type ze_image_region_t = _ze_image_region_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported initialization flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_init_flag_t {
    #[doc = "< default behavior"]
    ZE_INIT_FLAG_NONE = 0,
    #[doc = "< only initialize GPU drivers"]
    ZE_INIT_FLAG_GPU_ONLY = 1,
}
#[doc = ""]
#[doc = " @brief Supported initialization flags"]
pub use self::_ze_init_flag_t as ze_init_flag_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Initialize the 'One API' driver and must be called before any other"]
    #[doc = "        API function"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - If this function is not called then all other functions will return"]
    #[doc = "       ::ZE_RESULT_ERROR_UNINITIALIZED."]
    #[doc = "     - Only one instance of a driver per process will be initialized."]
    #[doc = "     - This function is thread-safe for scenarios where multiple libraries"]
    #[doc = "       may initialize the driver simultaneously."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + flags"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    pub fn zeInit(flags: ze_init_flag_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves driver instances"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A driver represents a collection of physical devices."]
    #[doc = "     - The application may pass nullptr for pDrivers when only querying the"]
    #[doc = "       number of drivers."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetPlatformIDs"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDriverGet(pCount: *mut u32, phDrivers: *mut ze_driver_handle_t) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported API versions"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - API versions contain major and minor attributes, use"]
#[doc = "       ::ZE_MAJOR_VERSION and ::ZE_MINOR_VERSION"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_api_version_t {
    #[doc = "< 0.91"]
    ZE_API_VERSION_1_0 = 91,
}
#[doc = ""]
#[doc = " @brief Supported API versions"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - API versions contain major and minor attributes, use"]
#[doc = "       ::ZE_MAJOR_VERSION and ::ZE_MINOR_VERSION"]
pub use self::_ze_api_version_t as ze_api_version_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Returns the API version supported by the specified driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == version`"]
    pub fn zeDriverGetApiVersion(
        hDriver: ze_driver_handle_t,
        version: *mut ze_api_version_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_driver_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_driver_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_DRIVER_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_driver_properties_t"]
pub use self::_ze_driver_properties_version_t as ze_driver_properties_version_t;
#[doc = ""]
#[doc = " @brief Driver universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_uuid_t {
    #[doc = "< Opaque data representing a driver UUID"]
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_driver_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_driver_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_driver_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_uuid_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_uuid_t),
            "::",
            stringify!(id)
        )
    );
}
#[doc = ""]
#[doc = " @brief Driver properties queried using ::zeDriverGetProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_properties_t {
    #[doc = "< [in] ::ZE_DRIVER_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_driver_properties_version_t,
    #[doc = "< [out] universal unique identifier."]
    pub uuid: ze_driver_uuid_t,
    #[doc = "< [out] driver version"]
    #[doc = "< The driver version is a non-zero, monotonically increasing value where"]
    #[doc = "< higher values always indicate a more recent version."]
    pub driverVersion: u32,
}
#[test]
fn bindgen_test_layout__ze_driver_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_driver_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_driver_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_properties_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_driver_properties_t>())).uuid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_properties_t>())).driverVersion as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_properties_t),
            "::",
            stringify!(driverVersion)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves properties of the driver."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clGetPlatformInfo**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pDriverProperties`"]
    pub fn zeDriverGetProperties(
        hDriver: ze_driver_handle_t,
        pDriverProperties: *mut ze_driver_properties_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_driver_ipc_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_driver_ipc_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_DRIVER_IPC_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_driver_ipc_properties_t"]
pub use self::_ze_driver_ipc_properties_version_t as ze_driver_ipc_properties_version_t;
#[doc = ""]
#[doc = " @brief IPC properties queried using ::zeDriverGetIPCProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_driver_ipc_properties_t {
    #[doc = "< [in] ::ZE_DRIVER_IPC_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_driver_ipc_properties_version_t,
    #[doc = "< [out] Supports passing memory allocations between processes. See"]
    #[doc = "< ::::zeDriverGetMemIpcHandle."]
    pub memsSupported: ze_bool_t,
    #[doc = "< [out] Supports passing events between processes. See"]
    #[doc = "< ::::zeEventPoolGetIpcHandle."]
    pub eventsSupported: ze_bool_t,
}
#[test]
fn bindgen_test_layout__ze_driver_ipc_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_driver_ipc_properties_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_driver_ipc_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_driver_ipc_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_driver_ipc_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_ipc_properties_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_ipc_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_ipc_properties_t>())).memsSupported as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_ipc_properties_t),
            "::",
            stringify!(memsSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_driver_ipc_properties_t>())).eventsSupported as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_driver_ipc_properties_t),
            "::",
            stringify!(eventsSupported)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves IPC attributes of the driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pIPCProperties`"]
    pub fn zeDriverGetIPCProperties(
        hDriver: ze_driver_handle_t,
        pIPCProperties: *mut ze_driver_ipc_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves an extension function for the specified driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clGetExtensionFunctionAddressForPlatform**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pFuncName`"]
    #[doc = "         + `nullptr == pfunc`"]
    pub fn zeDriverGetExtensionFunctionAddress(
        hDriver: ze_driver_handle_t,
        pFuncName: *const ::std::os::raw::c_char,
        pfunc: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves devices within a driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGet(
        hDriver: ze_driver_handle_t,
        pCount: *mut u32,
        phDevices: *mut ze_device_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves a sub-device from a device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clCreateSubDevices"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGetSubDevices(
        hDevice: ze_device_handle_t,
        pCount: *mut u32,
        phSubdevices: *mut ze_device_handle_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_device_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_DEVICE_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_device_properties_t"]
pub use self::_ze_device_properties_version_t as ze_device_properties_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported device types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_type_t {
    #[doc = "< Graphics Processing Unit"]
    ZE_DEVICE_TYPE_GPU = 1,
    #[doc = "< Field Programmable Gate Array"]
    ZE_DEVICE_TYPE_FPGA = 2,
}
#[doc = ""]
#[doc = " @brief Supported device types"]
pub use self::_ze_device_type_t as ze_device_type_t;
#[doc = ""]
#[doc = " @brief Device universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_uuid_t {
    #[doc = "< Opaque data representing a device UUID"]
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_device_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_device_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_device_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_uuid_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_uuid_t),
            "::",
            stringify!(id)
        )
    );
}
#[doc = ""]
#[doc = " @brief Device properties queried using ::zeDeviceGetProperties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_device_properties_t {
    #[doc = "< [in] ::ZE_DEVICE_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_device_properties_version_t,
    #[doc = "< [out] generic device type"]
    pub type_: ze_device_type_t,
    #[doc = "< [out] vendor id from PCI configuration"]
    pub vendorId: u32,
    #[doc = "< [out] device id from PCI configuration"]
    pub deviceId: u32,
    #[doc = "< [out] universal unique identifier."]
    pub uuid: ze_device_uuid_t,
    #[doc = "< [out] If the device handle used for query represents a sub-device."]
    pub isSubdevice: ze_bool_t,
    #[doc = "< [out] sub-device id. Only valid if isSubdevice is true."]
    pub subdeviceId: u32,
    #[doc = "< [out] Clock rate for device core."]
    pub coreClockRate: u32,
    #[doc = "< [out] Supports unified physical memory between Host and device."]
    pub unifiedMemorySupported: ze_bool_t,
    #[doc = "< [out] Supports error correction memory access."]
    pub eccMemorySupported: ze_bool_t,
    #[doc = "< [out] Supports on-demand page-faulting."]
    pub onDemandPageFaultsSupported: ze_bool_t,
    #[doc = "< [out] Maximum number of logical command queues."]
    pub maxCommandQueues: u32,
    #[doc = "< [out] Number of asynchronous compute engines"]
    pub numAsyncComputeEngines: u32,
    #[doc = "< [out] Number of asynchronous copy engines"]
    pub numAsyncCopyEngines: u32,
    #[doc = "< [out] Maximum priority for command queues. Higher value is higher"]
    #[doc = "< priority."]
    pub maxCommandQueuePriority: u32,
    #[doc = "< [out] Number of threads per EU."]
    pub numThreadsPerEU: u32,
    #[doc = "< [out] The physical EU simd width."]
    pub physicalEUSimdWidth: u32,
    #[doc = "< [out] Number of EUs per sub-slice."]
    pub numEUsPerSubslice: u32,
    #[doc = "< [out] Number of sub-slices per slice."]
    pub numSubslicesPerSlice: u32,
    #[doc = "< [out] Number of slices."]
    pub numSlices: u32,
    #[doc = "< [out] Returns the resolution of device timer in nanoseconds used for"]
    #[doc = "< profiling, timestamps, etc."]
    pub timerResolution: u64,
    #[doc = "< [out] Device name"]
    pub name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout__ze_device_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_properties_t>(),
        352usize,
        concat!("Size of: ", stringify!(_ze_device_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).vendorId as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).deviceId as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(deviceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).uuid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).isSubdevice as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(isSubdevice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).subdeviceId as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(subdeviceId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).coreClockRate as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(coreClockRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).unifiedMemorySupported as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(unifiedMemorySupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).eccMemorySupported as *const _
                as usize
        },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(eccMemorySupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).onDemandPageFaultsSupported
                as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(onDemandPageFaultsSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).maxCommandQueues as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(maxCommandQueues)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numAsyncComputeEngines as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numAsyncComputeEngines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numAsyncCopyEngines as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numAsyncCopyEngines)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).maxCommandQueuePriority as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(maxCommandQueuePriority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numThreadsPerEU as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numThreadsPerEU)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).physicalEUSimdWidth as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(physicalEUSimdWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numEUsPerSubslice as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numEUsPerSubslice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numSubslicesPerSlice as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numSubslicesPerSlice)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).numSlices as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(numSlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_properties_t>())).timerResolution as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(timerResolution)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_device_properties_t>())).name as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_properties_t),
            "::",
            stringify!(name)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pDeviceProperties`"]
    pub fn zeDeviceGetProperties(
        hDevice: ze_device_handle_t,
        pDeviceProperties: *mut ze_device_properties_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_device_compute_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_compute_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_DEVICE_COMPUTE_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_device_compute_properties_t"]
pub use self::_ze_device_compute_properties_version_t as ze_device_compute_properties_version_t;
#[doc = ""]
#[doc = " @brief Device compute properties queried using ::zeDeviceGetComputeProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_compute_properties_t {
    #[doc = "< [in] ::ZE_DEVICE_COMPUTE_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_device_compute_properties_version_t,
    #[doc = "< [out] Maximum items per compute group. (maxGroupSizeX * maxGroupSizeY"]
    #[doc = "< * maxGroupSizeZ) <= maxTotalGroupSize"]
    pub maxTotalGroupSize: u32,
    #[doc = "< [out] Maximum items for X dimension in group"]
    pub maxGroupSizeX: u32,
    #[doc = "< [out] Maximum items for Y dimension in group"]
    pub maxGroupSizeY: u32,
    #[doc = "< [out] Maximum items for Z dimension in group"]
    pub maxGroupSizeZ: u32,
    #[doc = "< [out] Maximum groups that can be launched for x dimension"]
    pub maxGroupCountX: u32,
    #[doc = "< [out] Maximum groups that can be launched for y dimension"]
    pub maxGroupCountY: u32,
    #[doc = "< [out] Maximum groups that can be launched for z dimension"]
    pub maxGroupCountZ: u32,
    #[doc = "< [out] Maximum shared local memory per group."]
    pub maxSharedLocalMemory: u32,
    #[doc = "< [out] Number of subgroup sizes supported. This indicates number of"]
    #[doc = "< entries in subGroupSizes."]
    pub numSubGroupSizes: u32,
    #[doc = "< [out] Size group sizes supported."]
    pub subGroupSizes: [u32; 8usize],
}
#[test]
fn bindgen_test_layout__ze_device_compute_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_compute_properties_t>(),
        72usize,
        concat!("Size of: ", stringify!(_ze_device_compute_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_compute_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_device_compute_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxTotalGroupSize
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxTotalGroupSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupSizeX as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupSizeY as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupSizeZ as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupSizeZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupCountX as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupCountX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupCountY as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupCountY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxGroupCountZ as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxGroupCountZ)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).maxSharedLocalMemory
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(maxSharedLocalMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).numSubGroupSizes as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(numSubGroupSizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_compute_properties_t>())).subGroupSizes as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_compute_properties_t),
            "::",
            stringify!(subGroupSizes)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves compute properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pComputeProperties`"]
    pub fn zeDeviceGetComputeProperties(
        hDevice: ze_device_handle_t,
        pComputeProperties: *mut ze_device_compute_properties_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_device_kernel_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_kernel_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_DEVICE_KERNEL_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_device_kernel_properties_t"]
pub use self::_ze_device_kernel_properties_version_t as ze_device_kernel_properties_version_t;
#[doc = ""]
#[doc = " @brief Native kernel universal unique id (UUID)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_native_kernel_uuid_t {
    #[doc = "< Opaque data representing a native kernel UUID"]
    pub id: [u8; 16usize],
}
#[test]
fn bindgen_test_layout__ze_native_kernel_uuid_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_native_kernel_uuid_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_native_kernel_uuid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_native_kernel_uuid_t>(),
        1usize,
        concat!("Alignment of ", stringify!(_ze_native_kernel_uuid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_native_kernel_uuid_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_native_kernel_uuid_t),
            "::",
            stringify!(id)
        )
    );
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Floating Point capabilities"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - floating-point capabilities of the device."]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_fp_capabilities_t {
    #[doc = "< None"]
    ZE_FP_CAPS_NONE = 0,
    #[doc = "< Supports denorms"]
    ZE_FP_CAPS_DENORM = 1,
    #[doc = "< Supports INF and quiet NaNs"]
    ZE_FP_CAPS_INF_NAN = 2,
    #[doc = "< Supports rounding to nearest even rounding mode"]
    ZE_FP_CAPS_ROUND_TO_NEAREST = 4,
    #[doc = "< Supports rounding to zero."]
    ZE_FP_CAPS_ROUND_TO_ZERO = 8,
    #[doc = "< Supports rounding to both positive and negative INF."]
    ZE_FP_CAPS_ROUND_TO_INF = 16,
    #[doc = "< Supports IEEE754-2008 fused multiply-add."]
    ZE_FP_CAPS_FMA = 32,
    #[doc = "< Supports rounding as defined by IEEE754 for divide and sqrt"]
    #[doc = "< operations."]
    ZE_FP_CAPS_ROUNDED_DIVIDE_SQRT = 64,
    #[doc = "< Uses software implementation for basic floating-point operations."]
    ZE_FP_CAPS_SOFT_FLOAT = 128,
}
#[doc = ""]
#[doc = " @brief Floating Point capabilities"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - floating-point capabilities of the device."]
pub use self::_ze_fp_capabilities_t as ze_fp_capabilities_t;
#[doc = ""]
#[doc = " @brief Device properties queried using ::zeDeviceGetKernelProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_kernel_properties_t {
    #[doc = "< [in] ::ZE_DEVICE_KERNEL_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_device_kernel_properties_version_t,
    #[doc = "< [out] Maximum supported SPIR-V version."]
    #[doc = "< Returns zero if SPIR-V is not supported."]
    #[doc = "< Contains major and minor attributes, use ::ZE_MAJOR_VERSION and ::ZE_MINOR_VERSION."]
    pub spirvVersionSupported: u32,
    #[doc = "< [out] Compatibility UUID of supported native kernel."]
    #[doc = "< UUID may or may not be the same across driver release, devices, or"]
    #[doc = "< operating systems."]
    #[doc = "< Application is responsible for ensuring UUID matches before creating"]
    #[doc = "< module using"]
    #[doc = "< previously created native kernel."]
    pub nativeKernelSupported: ze_native_kernel_uuid_t,
    #[doc = "< [out] Supports 16-bit floating-point operations"]
    pub fp16Supported: ze_bool_t,
    #[doc = "< [out] Supports 64-bit floating-point operations"]
    pub fp64Supported: ze_bool_t,
    #[doc = "< [out] Supports 64-bit atomic operations"]
    pub int64AtomicsSupported: ze_bool_t,
    #[doc = "< [out] Supports four component dot product and accumulate operations"]
    pub dp4aSupported: ze_bool_t,
    #[doc = "< [out] Capabilities for half-precision floating-point operations."]
    pub halfFpCapabilities: ze_fp_capabilities_t,
    #[doc = "< [out] Capabilities for single-precision floating-point operations."]
    pub singleFpCapabilities: ze_fp_capabilities_t,
    #[doc = "< [out] Capabilities for double-precision floating-point operations."]
    pub doubleFpCapabilities: ze_fp_capabilities_t,
    #[doc = "< [out] Maximum kernel argument size that is supported."]
    pub maxArgumentsSize: u32,
    #[doc = "< [out] Maximum size of internal buffer that holds output of printf"]
    #[doc = "< calls from kernel."]
    pub printfBufferSize: u32,
}
#[test]
fn bindgen_test_layout__ze_device_kernel_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_kernel_properties_t>(),
        48usize,
        concat!("Size of: ", stringify!(_ze_device_kernel_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_kernel_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_device_kernel_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).spirvVersionSupported
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(spirvVersionSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).nativeKernelSupported
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(nativeKernelSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).fp16Supported as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(fp16Supported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).fp64Supported as *const _
                as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(fp64Supported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).int64AtomicsSupported
                as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(int64AtomicsSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).dp4aSupported as *const _
                as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(dp4aSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).halfFpCapabilities
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(halfFpCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).singleFpCapabilities
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(singleFpCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).doubleFpCapabilities
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(doubleFpCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).maxArgumentsSize as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(maxArgumentsSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_kernel_properties_t>())).printfBufferSize as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_kernel_properties_t),
            "::",
            stringify!(printfBufferSize)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves kernel properties of the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pKernelProperties`"]
    pub fn zeDeviceGetKernelProperties(
        hDevice: ze_device_handle_t,
        pKernelProperties: *mut ze_device_kernel_properties_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_device_memory_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_memory_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_DEVICE_MEMORY_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_device_memory_properties_t"]
pub use self::_ze_device_memory_properties_version_t as ze_device_memory_properties_version_t;
#[doc = ""]
#[doc = " @brief Device local memory properties queried using"]
#[doc = "        ::zeDeviceGetMemoryProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_memory_properties_t {
    #[doc = "< [in] ::ZE_DEVICE_MEMORY_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_device_memory_properties_version_t,
    #[doc = "< [out] Maximum clock rate for device memory."]
    pub maxClockRate: u32,
    #[doc = "< [out] Maximum bus width between device and memory."]
    pub maxBusWidth: u32,
    #[doc = "< [out] Total memory size in bytes."]
    pub totalSize: u64,
}
#[test]
fn bindgen_test_layout__ze_device_memory_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_memory_properties_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_device_memory_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_memory_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_memory_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).maxClockRate as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(maxClockRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).maxBusWidth as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(maxBusWidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_properties_t>())).totalSize as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_properties_t),
            "::",
            stringify!(totalSize)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves local memory properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Properties are reported for each physical memory type supported by the"]
    #[doc = "       device."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeDeviceGetMemoryProperties(
        hDevice: ze_device_handle_t,
        pCount: *mut u32,
        pMemProperties: *mut ze_device_memory_properties_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_device_memory_access_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_memory_access_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_DEVICE_MEMORY_ACCESS_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_device_memory_access_properties_t"]
pub use self::_ze_device_memory_access_properties_version_t as ze_device_memory_access_properties_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Memory access capabilities"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - Supported access capabilities for different types of memory"]
#[doc = "       allocations"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_memory_access_capabilities_t {
    #[doc = "< Access not supported"]
    ZE_MEMORY_ACCESS_NONE = 0,
    #[doc = "< Supports load/store access"]
    ZE_MEMORY_ACCESS = 1,
    #[doc = "< Supports atomic access"]
    ZE_MEMORY_ATOMIC_ACCESS = 2,
    #[doc = "< Supports concurrent access"]
    ZE_MEMORY_CONCURRENT_ACCESS = 4,
    #[doc = "< Supports concurrent atomic access"]
    ZE_MEMORY_CONCURRENT_ATOMIC_ACCESS = 8,
}
#[doc = ""]
#[doc = " @brief Memory access capabilities"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - Supported access capabilities for different types of memory"]
#[doc = "       allocations"]
pub use self::_ze_memory_access_capabilities_t as ze_memory_access_capabilities_t;
#[doc = ""]
#[doc = " @brief Device memory access properties queried using"]
#[doc = "        ::zeDeviceGetMemoryAccessProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_memory_access_properties_t {
    #[doc = "< [in] ::ZE_DEVICE_MEMORY_ACCESS_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_device_memory_access_properties_version_t,
    #[doc = "< [out] Bitfield describing host memory capabilities"]
    pub hostAllocCapabilities: ze_memory_access_capabilities_t,
    #[doc = "< [out] Bitfield describing device memory capabilities"]
    pub deviceAllocCapabilities: ze_memory_access_capabilities_t,
    #[doc = "< [out] Bitfield describing shared (single-device) memory capabilities"]
    pub sharedSingleDeviceAllocCapabilities: ze_memory_access_capabilities_t,
    #[doc = "< [out] Bitfield describing shared (cross-device) memory capabilities"]
    pub sharedCrossDeviceAllocCapabilities: ze_memory_access_capabilities_t,
    #[doc = "< [out] Bitfield describing shared (system) memory capabilities"]
    pub sharedSystemAllocCapabilities: ze_memory_access_capabilities_t,
}
#[test]
fn bindgen_test_layout__ze_device_memory_access_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_memory_access_properties_t>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_ze_device_memory_access_properties_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_memory_access_properties_t>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_device_memory_access_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>())).hostAllocCapabilities
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(hostAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .deviceAllocCapabilities as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(deviceAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .sharedSingleDeviceAllocCapabilities as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(sharedSingleDeviceAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .sharedCrossDeviceAllocCapabilities as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(sharedCrossDeviceAllocCapabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_memory_access_properties_t>()))
                .sharedSystemAllocCapabilities as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_memory_access_properties_t),
            "::",
            stringify!(sharedSystemAllocCapabilities)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves memory access properties of the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pMemAccessProperties`"]
    pub fn zeDeviceGetMemoryAccessProperties(
        hDevice: ze_device_handle_t,
        pMemAccessProperties: *mut ze_device_memory_access_properties_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_device_cache_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_cache_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_DEVICE_CACHE_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_device_cache_properties_t"]
pub use self::_ze_device_cache_properties_version_t as ze_device_cache_properties_version_t;
#[doc = ""]
#[doc = " @brief Device cache properties queried using ::zeDeviceGetCacheProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_cache_properties_t {
    #[doc = "< [in] ::ZE_DEVICE_CACHE_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_device_cache_properties_version_t,
    #[doc = "< [out] Support User control on Intermediate Cache (i.e. Resize SLM"]
    #[doc = "< section vs Generic Cache)"]
    pub intermediateCacheControlSupported: ze_bool_t,
    #[doc = "< [out] Per-cache Intermediate Cache (L1/L2) size, in bytes"]
    pub intermediateCacheSize: usize,
    #[doc = "< [out] Cacheline size in bytes for intermediate cacheline (L1/L2)."]
    pub intermediateCachelineSize: u32,
    #[doc = "< [out] Support User control on Last Level Cache (i.e. Resize SLM"]
    #[doc = "< section vs Generic Cache)."]
    pub lastLevelCacheSizeControlSupported: ze_bool_t,
    #[doc = "< [out] Per-cache Last Level Cache (L3) size, in bytes"]
    pub lastLevelCacheSize: usize,
    #[doc = "< [out] Cacheline size in bytes for last-level cacheline (L3)."]
    pub lastLevelCachelineSize: u32,
}
#[test]
fn bindgen_test_layout__ze_device_cache_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_cache_properties_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_device_cache_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_cache_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_cache_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>()))
                .intermediateCacheControlSupported as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(intermediateCacheControlSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).intermediateCacheSize
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(intermediateCacheSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).intermediateCachelineSize
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(intermediateCachelineSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>()))
                .lastLevelCacheSizeControlSupported as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(lastLevelCacheSizeControlSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).lastLevelCacheSize as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(lastLevelCacheSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_cache_properties_t>())).lastLevelCachelineSize
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_cache_properties_t),
            "::",
            stringify!(lastLevelCachelineSize)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves cache properties of the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clGetDeviceInfo"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCacheProperties`"]
    pub fn zeDeviceGetCacheProperties(
        hDevice: ze_device_handle_t,
        pCacheProperties: *mut ze_device_cache_properties_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_device_image_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_image_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_DEVICE_IMAGE_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_device_image_properties_t"]
pub use self::_ze_device_image_properties_version_t as ze_device_image_properties_version_t;
#[doc = ""]
#[doc = " @brief Device image properties queried using ::zeDeviceGetComputeProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_image_properties_t {
    #[doc = "< [in] ::ZE_DEVICE_IMAGE_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_device_image_properties_version_t,
    #[doc = "< [out] Supports reading and writing of images. See"]
    #[doc = "< ::::zeImageGetProperties for format-specific capabilities."]
    pub supported: ze_bool_t,
    #[doc = "< [out] Maximum image dimensions for 1D resources."]
    pub maxImageDims1D: u32,
    #[doc = "< [out] Maximum image dimensions for 2D resources."]
    pub maxImageDims2D: u32,
    #[doc = "< [out] Maximum image dimensions for 3D resources."]
    pub maxImageDims3D: u32,
    #[doc = "< [out] Maximum image buffer size in bytes."]
    pub maxImageBufferSize: u64,
    #[doc = "< [out] Maximum image array slices"]
    pub maxImageArraySlices: u32,
    #[doc = "< [out] Max samplers that can be used in kernel."]
    pub maxSamplers: u32,
    #[doc = "< [out] Returns the maximum number of simultaneous image objects that"]
    #[doc = "< can be read from by a kernel."]
    pub maxReadImageArgs: u32,
    #[doc = "< [out] Returns the maximum number of simultaneous image objects that"]
    #[doc = "< can be written to by a kernel."]
    pub maxWriteImageArgs: u32,
}
#[test]
fn bindgen_test_layout__ze_device_image_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_image_properties_t>(),
        48usize,
        concat!("Size of: ", stringify!(_ze_device_image_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_image_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_device_image_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).supported as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(supported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageDims1D as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageDims1D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageDims2D as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageDims2D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageDims3D as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageDims3D)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageBufferSize as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageBufferSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxImageArraySlices
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxImageArraySlices)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxSamplers as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxSamplers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxReadImageArgs as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxReadImageArgs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_image_properties_t>())).maxWriteImageArgs as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_image_properties_t),
            "::",
            stringify!(maxWriteImageArgs)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves image X_DEVICE_MEMORY_ACCESS_PROPERTIES_VERSION_CURRENT of"]
    #[doc = "        the device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pImageProperties`"]
    pub fn zeDeviceGetImageProperties(
        hDevice: ze_device_handle_t,
        pImageProperties: *mut ze_device_image_properties_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_device_p2p_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_p2p_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_DEVICE_P2P_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_device_p2p_properties_t"]
pub use self::_ze_device_p2p_properties_version_t as ze_device_p2p_properties_version_t;
#[doc = ""]
#[doc = " @brief Device properties queried using ::zeDeviceGetP2PProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_p2p_properties_t {
    #[doc = "< [in] ::ZE_DEVICE_P2P_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_device_p2p_properties_version_t,
    #[doc = "< [out] Supports access between peer devices."]
    pub accessSupported: ze_bool_t,
    #[doc = "< [out] Supports atomics between peer devices."]
    pub atomicsSupported: ze_bool_t,
}
#[test]
fn bindgen_test_layout__ze_device_p2p_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_p2p_properties_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_device_p2p_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_p2p_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_device_p2p_properties_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_p2p_properties_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_p2p_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_p2p_properties_t>())).accessSupported as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_p2p_properties_t),
            "::",
            stringify!(accessSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_p2p_properties_t>())).atomicsSupported as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_p2p_properties_t),
            "::",
            stringify!(atomicsSupported)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves Peer-to-Peer properties between one device and a peer"]
    #[doc = "        devices"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hPeerDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pP2PProperties`"]
    pub fn zeDeviceGetP2PProperties(
        hDevice: ze_device_handle_t,
        hPeerDevice: ze_device_handle_t,
        pP2PProperties: *mut ze_device_p2p_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries if one device can directly access peer device allocations"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Any device can access any other device within a node through a"]
    #[doc = "       scale-up fabric."]
    #[doc = "     - The following are conditions for CanAccessPeer query."]
    #[doc = "         + If both device and peer device are the same then return true."]
    #[doc = "         + If both sub-device and peer sub-device are the same then return"]
    #[doc = "           true."]
    #[doc = "         + If both are sub-devices and share the same parent device then"]
    #[doc = "           return true."]
    #[doc = "         + If both device and remote device are connected by a direct or"]
    #[doc = "           indirect scale-up fabric or over PCIe (same root complex or shared"]
    #[doc = "           PCIe switch) then true."]
    #[doc = "         + If both sub-device and remote parent device (and vice-versa) are"]
    #[doc = "           connected by a direct or indirect scale-up fabric or over PCIe"]
    #[doc = "           (same root complex or shared PCIe switch) then true."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hPeerDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == value`"]
    pub fn zeDeviceCanAccessPeer(
        hDevice: ze_device_handle_t,
        hPeerDevice: ze_device_handle_t,
        value: *mut ze_bool_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported Cache Config"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - Supported Cache Config (Default, Large SLM, Large Data Cache)"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_cache_config_t {
    #[doc = "< Default Config"]
    ZE_CACHE_CONFIG_DEFAULT = 1,
    #[doc = "< Large SLM size"]
    ZE_CACHE_CONFIG_LARGE_SLM = 2,
    #[doc = "< Large General Data size"]
    ZE_CACHE_CONFIG_LARGE_DATA = 4,
}
#[doc = ""]
#[doc = " @brief Supported Cache Config"]
#[doc = ""]
#[doc = " @details"]
#[doc = "     - Supported Cache Config (Default, Large SLM, Large Data Cache)"]
pub use self::_ze_cache_config_t as ze_cache_config_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Sets the preferred Last Level cache configuration for a device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same device handle."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + CacheConfig"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_FEATURE"]
    pub fn zeDeviceSetLastLevelCacheConfig(
        hDevice: ze_device_handle_t,
        CacheConfig: ze_cache_config_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_command_queue_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_command_queue_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_COMMAND_QUEUE_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_command_queue_desc_t"]
pub use self::_ze_command_queue_desc_version_t as ze_command_queue_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported command queue flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_command_queue_flag_t {
    #[doc = "< default behavior"]
    ZE_COMMAND_QUEUE_FLAG_NONE = 0,
    #[doc = "< command queue only supports enqueuing copy-only command lists"]
    ZE_COMMAND_QUEUE_FLAG_COPY_ONLY = 1,
    #[doc = "< command queue is not tied to a physical command queue; driver may"]
    #[doc = "< dynamically assign based on usage"]
    ZE_COMMAND_QUEUE_FLAG_LOGICAL_ONLY = 2,
    #[doc = "< command queue reserves and cannot consume more than a single slice."]
    #[doc = "< 'slice' size is device-specific.  cannot be combined with COPY_ONLY."]
    ZE_COMMAND_QUEUE_FLAG_SINGLE_SLICE_ONLY = 4,
    #[doc = "< command queue supports command list with cooperative kernels. See"]
    #[doc = "< ::zeCommandListAppendLaunchCooperativeKernel for more details. cannot"]
    #[doc = "< be combined with COPY_ONLY."]
    ZE_COMMAND_QUEUE_FLAG_SUPPORTS_COOPERATIVE_KERNELS = 8,
}
#[doc = ""]
#[doc = " @brief Supported command queue flags"]
pub use self::_ze_command_queue_flag_t as ze_command_queue_flag_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported command queue modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_command_queue_mode_t {
    #[doc = "< implicit default behavior; uses driver-based heuristics"]
    ZE_COMMAND_QUEUE_MODE_DEFAULT = 0,
    #[doc = "< Device execution always completes immediately on execute;"]
    #[doc = "< Host thread is blocked using wait on implicit synchronization object"]
    ZE_COMMAND_QUEUE_MODE_SYNCHRONOUS = 1,
    #[doc = "< Device execution is scheduled and will complete in future;"]
    #[doc = "< explicit synchronization object must be used to determine completeness"]
    ZE_COMMAND_QUEUE_MODE_ASYNCHRONOUS = 2,
}
#[doc = ""]
#[doc = " @brief Supported command queue modes"]
pub use self::_ze_command_queue_mode_t as ze_command_queue_mode_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported command queue priorities"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_command_queue_priority_t {
    #[doc = "< [default] normal priority"]
    ZE_COMMAND_QUEUE_PRIORITY_NORMAL = 0,
    #[doc = "< lower priority than normal"]
    ZE_COMMAND_QUEUE_PRIORITY_LOW = 1,
    #[doc = "< higher priority than normal"]
    ZE_COMMAND_QUEUE_PRIORITY_HIGH = 2,
}
#[doc = ""]
#[doc = " @brief Supported command queue priorities"]
pub use self::_ze_command_queue_priority_t as ze_command_queue_priority_t;
#[doc = ""]
#[doc = " @brief Command Queue descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_queue_desc_t {
    #[doc = "< [in] ::ZE_COMMAND_QUEUE_DESC_VERSION_CURRENT"]
    pub version: ze_command_queue_desc_version_t,
    #[doc = "< [in] creation flags"]
    pub flags: ze_command_queue_flag_t,
    #[doc = "< [in] operation mode"]
    pub mode: ze_command_queue_mode_t,
    #[doc = "< [in] priority"]
    pub priority: ze_command_queue_priority_t,
    #[doc = "< [in] if logical-only flag is set, then will be ignored;"]
    #[doc = "< if supports-cooperative-kernels is set, then may be ignored;"]
    #[doc = "< else-if copy-only flag is set, then must be less than ::ze_device_properties_t.numAsyncCopyEngines;"]
    #[doc = "< otherwise must be less than"]
    #[doc = "< ::ze_device_properties_t.numAsyncComputeEngines. When using sub-devices"]
    #[doc = "< the ::ze_device_properties_t.numAsyncComputeEngines must be queried"]
    #[doc = "< from the sub-device being used."]
    pub ordinal: u32,
}
#[test]
fn bindgen_test_layout__ze_command_queue_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_queue_desc_t>(),
        20usize,
        concat!("Size of: ", stringify!(_ze_command_queue_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_queue_desc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_command_queue_desc_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).mode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).priority as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_command_queue_desc_t>())).ordinal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_queue_desc_t),
            "::",
            stringify!(ordinal)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a command queue on the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The command queue can only be used on the device on which it was"]
    #[doc = "       created."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clCreateCommandQueue**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_COMMAND_QUEUE_DESC_VERSION_CURRENT < desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + desc->flags"]
    #[doc = "         + desc->mode"]
    #[doc = "         + desc->priority"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeCommandQueueCreate(
        hDevice: ze_device_handle_t,
        desc: *const ze_command_queue_desc_t,
        phCommandQueue: *mut ze_command_queue_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the command queue before it is deleted"]
    #[doc = "     - The implementation of this function will immediately free all Host and"]
    #[doc = "       Device allocations associated with this command queue"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command queue handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clReleaseCommandQueue**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeCommandQueueDestroy(hCommandQueue: ze_command_queue_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Executes a command list in a command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - vkQueueSubmit"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phCommandLists`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `0 == numCommandLists`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_COMMAND_LIST_TYPE"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandQueueExecuteCommandLists(
        hCommandQueue: ze_command_queue_handle_t,
        numCommandLists: u32,
        phCommandLists: *mut ze_command_list_handle_t,
        hFence: ze_fence_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Synchronizes a command queue by waiting on the host."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + timeout expired"]
    pub fn zeCommandQueueSynchronize(
        hCommandQueue: ze_command_queue_handle_t,
        timeout: u32,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_command_list_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_command_list_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_COMMAND_LIST_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_command_list_desc_t"]
pub use self::_ze_command_list_desc_version_t as ze_command_list_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported command list creation flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_command_list_flag_t {
    #[doc = "< default behavior"]
    ZE_COMMAND_LIST_FLAG_NONE = 0,
    #[doc = "< command list **only** contains copy operations (and synchronization primitives)."]
    #[doc = "< this command list may **only** be submitted to a command queue created"]
    #[doc = "< with ::ZE_COMMAND_QUEUE_FLAG_COPY_ONLY."]
    ZE_COMMAND_LIST_FLAG_COPY_ONLY = 1,
    #[doc = "< driver may reorder programs and copys between barriers and"]
    #[doc = "< synchronization primitives."]
    #[doc = "< using this flag may increase Host overhead of ::zeCommandListClose."]
    #[doc = "< therefore, this flag should **not** be set for low-latency usage-models."]
    ZE_COMMAND_LIST_FLAG_RELAXED_ORDERING = 2,
    #[doc = "< driver may perform additional optimizations that increase dexecution"]
    #[doc = "< throughput."]
    #[doc = "< using this flag may increase Host overhead of ::zeCommandListClose and ::zeCommandQueueExecuteCommandLists."]
    #[doc = "< therefore, this flag should **not** be set for low-latency usage-models."]
    ZE_COMMAND_LIST_FLAG_MAXIMIZE_THROUGHPUT = 4,
    #[doc = "< command list should be optimized for submission to a single command"]
    #[doc = "< queue and device engine."]
    #[doc = "< driver **must** disable any implicit optimizations for distributing"]
    #[doc = "< work across multiple engines."]
    #[doc = "< this flag should be used when applications want full control over"]
    #[doc = "< multi-engine submission and scheduling."]
    ZE_COMMAND_LIST_FLAG_EXPLICIT_ONLY = 8,
}
#[doc = ""]
#[doc = " @brief Supported command list creation flags"]
pub use self::_ze_command_list_flag_t as ze_command_list_flag_t;
#[doc = ""]
#[doc = " @brief Command List descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_command_list_desc_t {
    #[doc = "< [in] ::ZE_COMMAND_LIST_DESC_VERSION_CURRENT"]
    pub version: ze_command_list_desc_version_t,
    #[doc = "< [in] creation flags"]
    pub flags: ze_command_list_flag_t,
}
#[test]
fn bindgen_test_layout__ze_command_list_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_command_list_desc_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_command_list_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_command_list_desc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_command_list_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_list_desc_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_command_list_desc_t>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_command_list_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a command list on the device for submitting commands to any"]
    #[doc = "        command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The command list can only be used on the device on which it was"]
    #[doc = "       created."]
    #[doc = "     - The command list is created in the 'open' state."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_COMMAND_LIST_DESC_VERSION_CURRENT < desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + desc->flags"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeCommandListCreate(
        hDevice: ze_device_handle_t,
        desc: *const ze_command_list_desc_t,
        phCommandList: *mut ze_command_list_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a command list on the device with an implicit command queue"]
    #[doc = "        for immediate submission of commands."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The command list can only be used on the device on which it was"]
    #[doc = "       created."]
    #[doc = "     - The command list is created in the 'open' state and never needs to be"]
    #[doc = "       closed."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == altdesc`"]
    #[doc = "         + `nullptr == phCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_COMMAND_QUEUE_DESC_VERSION_CURRENT < altdesc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + altdesc->flags"]
    #[doc = "         + altdesc->mode"]
    #[doc = "         + altdesc->priority"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeCommandListCreateImmediate(
        hDevice: ze_device_handle_t,
        altdesc: *const ze_command_queue_desc_t,
        phCommandList: *mut ze_command_list_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the command list before it is deleted"]
    #[doc = "     - The implementation of this function will immediately free all Host and"]
    #[doc = "       Device allocations associated with this command list."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeCommandListDestroy(hCommandList: ze_command_list_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Closes a command list; ready to be executed by a command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    pub fn zeCommandListClose(hCommandList: ze_command_list_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Reset a command list to initial (empty) state; ready for appending"]
    #[doc = "        commands."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the command list before it is reset"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    pub fn zeCommandListReset(hCommandList: ze_command_list_handle_t) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_image_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_image_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_IMAGE_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_image_desc_t"]
pub use self::_ze_image_desc_version_t as ze_image_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported image creation flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_image_flag_t {
    #[doc = "< programs will read contents"]
    ZE_IMAGE_FLAG_PROGRAM_READ = 1,
    #[doc = "< programs will write contents"]
    ZE_IMAGE_FLAG_PROGRAM_WRITE = 2,
    #[doc = "< device should cache contents"]
    ZE_IMAGE_FLAG_BIAS_CACHED = 4,
    #[doc = "< device should not cache contents"]
    ZE_IMAGE_FLAG_BIAS_UNCACHED = 8,
}
#[doc = ""]
#[doc = " @brief Supported image creation flags"]
pub use self::_ze_image_flag_t as ze_image_flag_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported image types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_image_type_t {
    #[doc = "< 1D"]
    ZE_IMAGE_TYPE_1D = 0,
    #[doc = "< 1D array"]
    ZE_IMAGE_TYPE_1DARRAY = 1,
    #[doc = "< 2D"]
    ZE_IMAGE_TYPE_2D = 2,
    #[doc = "< 2D array"]
    ZE_IMAGE_TYPE_2DARRAY = 3,
    #[doc = "< 3D"]
    ZE_IMAGE_TYPE_3D = 4,
    #[doc = "< Buffer"]
    ZE_IMAGE_TYPE_BUFFER = 5,
}
#[doc = ""]
#[doc = " @brief Supported image types"]
pub use self::_ze_image_type_t as ze_image_type_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported image format layouts"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_image_format_layout_t {
    #[doc = "< 8-bit single component layout"]
    ZE_IMAGE_FORMAT_LAYOUT_8 = 0,
    #[doc = "< 16-bit single component layout"]
    ZE_IMAGE_FORMAT_LAYOUT_16 = 1,
    #[doc = "< 32-bit single component layout"]
    ZE_IMAGE_FORMAT_LAYOUT_32 = 2,
    #[doc = "< 2-component 8-bit layout"]
    ZE_IMAGE_FORMAT_LAYOUT_8_8 = 3,
    #[doc = "< 4-component 8-bit layout"]
    ZE_IMAGE_FORMAT_LAYOUT_8_8_8_8 = 4,
    #[doc = "< 2-component 16-bit layout"]
    ZE_IMAGE_FORMAT_LAYOUT_16_16 = 5,
    #[doc = "< 4-component 16-bit layout"]
    ZE_IMAGE_FORMAT_LAYOUT_16_16_16_16 = 6,
    #[doc = "< 2-component 32-bit layout"]
    ZE_IMAGE_FORMAT_LAYOUT_32_32 = 7,
    #[doc = "< 4-component 32-bit layout"]
    ZE_IMAGE_FORMAT_LAYOUT_32_32_32_32 = 8,
    #[doc = "< 4-component 10_10_10_2 layout"]
    ZE_IMAGE_FORMAT_LAYOUT_10_10_10_2 = 9,
    #[doc = "< 3-component 11_11_10 layout"]
    ZE_IMAGE_FORMAT_LAYOUT_11_11_10 = 10,
    #[doc = "< 3-component 5_6_5 layout"]
    ZE_IMAGE_FORMAT_LAYOUT_5_6_5 = 11,
    #[doc = "< 4-component 5_5_5_1 layout"]
    ZE_IMAGE_FORMAT_LAYOUT_5_5_5_1 = 12,
    #[doc = "< 4-component 4_4_4_4 layout"]
    ZE_IMAGE_FORMAT_LAYOUT_4_4_4_4 = 13,
    #[doc = "< Media Format: Y8. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_Y8 = 14,
    #[doc = "< Media Format: NV12. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_NV12 = 15,
    #[doc = "< Media Format: YUYV. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_YUYV = 16,
    #[doc = "< Media Format: VYUY. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_VYUY = 17,
    #[doc = "< Media Format: YVYU. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_YVYU = 18,
    #[doc = "< Media Format: UYVY. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_UYVY = 19,
    #[doc = "< Media Format: AYUV. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_AYUV = 20,
    #[doc = "< Media Format: YUAV. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_YUAV = 21,
    #[doc = "< Media Format: P010. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_P010 = 22,
    #[doc = "< Media Format: Y410. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_Y410 = 23,
    #[doc = "< Media Format: P012. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_P012 = 24,
    #[doc = "< Media Format: Y16. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_Y16 = 25,
    #[doc = "< Media Format: P016. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_P016 = 26,
    #[doc = "< Media Format: Y216. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_Y216 = 27,
    #[doc = "< Media Format: P216. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_P216 = 28,
    #[doc = "< Media Format: P416. Format type and swizzle is ignored for this."]
    ZE_IMAGE_FORMAT_LAYOUT_P416 = 29,
}
#[doc = ""]
#[doc = " @brief Supported image format layouts"]
pub use self::_ze_image_format_layout_t as ze_image_format_layout_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported image format types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_image_format_type_t {
    #[doc = "< Unsigned integer"]
    ZE_IMAGE_FORMAT_TYPE_UINT = 0,
    #[doc = "< Signed integer"]
    ZE_IMAGE_FORMAT_TYPE_SINT = 1,
    #[doc = "< Unsigned normalized integer"]
    ZE_IMAGE_FORMAT_TYPE_UNORM = 2,
    #[doc = "< Signed normalized integer"]
    ZE_IMAGE_FORMAT_TYPE_SNORM = 3,
    #[doc = "< Float"]
    ZE_IMAGE_FORMAT_TYPE_FLOAT = 4,
}
#[doc = ""]
#[doc = " @brief Supported image format types"]
pub use self::_ze_image_format_type_t as ze_image_format_type_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported image format component swizzle into channel"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_image_format_swizzle_t {
    #[doc = "< Red component"]
    ZE_IMAGE_FORMAT_SWIZZLE_R = 0,
    #[doc = "< Green component"]
    ZE_IMAGE_FORMAT_SWIZZLE_G = 1,
    #[doc = "< Blue component"]
    ZE_IMAGE_FORMAT_SWIZZLE_B = 2,
    #[doc = "< Alpha component"]
    ZE_IMAGE_FORMAT_SWIZZLE_A = 3,
    #[doc = "< Zero"]
    ZE_IMAGE_FORMAT_SWIZZLE_0 = 4,
    #[doc = "< One"]
    ZE_IMAGE_FORMAT_SWIZZLE_1 = 5,
    #[doc = "< Don't care"]
    ZE_IMAGE_FORMAT_SWIZZLE_X = 6,
}
#[doc = ""]
#[doc = " @brief Supported image format component swizzle into channel"]
pub use self::_ze_image_format_swizzle_t as ze_image_format_swizzle_t;
#[doc = ""]
#[doc = " @brief Image format descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_format_desc_t {
    #[doc = "< [in] image format component layout"]
    pub layout: ze_image_format_layout_t,
    #[doc = "< [in] image format type. Media formats can't be used for"]
    #[doc = "< ::ZE_IMAGE_TYPE_BUFFER."]
    pub type_: ze_image_format_type_t,
    #[doc = "< [in] image component swizzle into channel x"]
    pub x: ze_image_format_swizzle_t,
    #[doc = "< [in] image component swizzle into channel y"]
    pub y: ze_image_format_swizzle_t,
    #[doc = "< [in] image component swizzle into channel z"]
    pub z: ze_image_format_swizzle_t,
    #[doc = "< [in] image component swizzle into channel w"]
    pub w: ze_image_format_swizzle_t,
}
#[test]
fn bindgen_test_layout__ze_image_format_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_format_desc_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_image_format_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_format_desc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_image_format_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_desc_t>())).layout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_desc_t),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_desc_t>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_desc_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_desc_t>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_desc_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_desc_t>())).y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_desc_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_desc_t>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_desc_t),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_format_desc_t>())).w as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_format_desc_t),
            "::",
            stringify!(w)
        )
    );
}
#[doc = ""]
#[doc = " @brief Image descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_desc_t {
    #[doc = "< [in] ::ZE_IMAGE_DESC_VERSION_CURRENT"]
    pub version: ze_image_desc_version_t,
    #[doc = "< [in] creation flags"]
    pub flags: ze_image_flag_t,
    #[doc = "< [in] image type"]
    pub type_: ze_image_type_t,
    #[doc = "< [in] image format"]
    pub format: ze_image_format_desc_t,
    #[doc = "< [in] width in pixels for ::ze_image_type_t::1D/2D/3D and bytes for"]
    #[doc = "< Buffer, see ::ze_device_image_properties_t::maxImageDims1D/2D/3D and"]
    #[doc = "< maxImageBufferSize."]
    pub width: u64,
    #[doc = "< [in] height in pixels (2D or 3D only), see"]
    #[doc = "< ::ze_device_image_properties_t::maxImageDims2D/3D"]
    pub height: u32,
    #[doc = "< [in] depth in pixels (3D only), see"]
    #[doc = "< ::ze_device_image_properties_t::maxImageDims3D"]
    pub depth: u32,
    #[doc = "< [in] array levels (array types only), see"]
    #[doc = "< ::ze_device_image_properties_t::maxImageArraySlices"]
    pub arraylevels: u32,
    #[doc = "< [in] mipmap levels (must be 0)"]
    pub miplevels: u32,
}
#[test]
fn bindgen_test_layout__ze_image_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_desc_t>(),
        64usize,
        concat!("Size of: ", stringify!(_ze_image_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_image_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).format as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).width as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).height as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).depth as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).arraylevels as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(arraylevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_desc_t>())).miplevels as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_desc_t),
            "::",
            stringify!(miplevels)
        )
    );
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_image_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_image_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_IMAGE_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_image_properties_t"]
pub use self::_ze_image_properties_version_t as ze_image_properties_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported sampler filtering flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_image_sampler_filter_flags_t {
    #[doc = "< device does not support filtering"]
    ZE_IMAGE_SAMPLER_FILTER_FLAGS_NONE = 0,
    #[doc = "< device supports point filtering"]
    ZE_IMAGE_SAMPLER_FILTER_FLAGS_POINT = 1,
    #[doc = "< device supports linear filtering"]
    ZE_IMAGE_SAMPLER_FILTER_FLAGS_LINEAR = 2,
}
#[doc = ""]
#[doc = " @brief Supported sampler filtering flags"]
pub use self::_ze_image_sampler_filter_flags_t as ze_image_sampler_filter_flags_t;
#[doc = ""]
#[doc = " @brief Image properties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_properties_t {
    #[doc = "< [in] ::ZE_IMAGE_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_image_properties_version_t,
    #[doc = "< [out] supported sampler filtering"]
    pub samplerFilterFlags: ze_image_sampler_filter_flags_t,
}
#[test]
fn bindgen_test_layout__ze_image_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_properties_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_image_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_image_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_properties_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_image_properties_t>())).samplerFilterFlags as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_properties_t),
            "::",
            stringify!(samplerFilterFlags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves supported properties of an image."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == pImageProperties`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_IMAGE_DESC_VERSION_CURRENT < desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + desc->flags"]
    #[doc = "         + desc->type"]
    pub fn zeImageGetProperties(
        hDevice: ze_device_handle_t,
        desc: *const ze_image_desc_t,
        pImageProperties: *mut ze_image_properties_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a image object on the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The image is only visible to the device on which it was created."]
    #[doc = "     - The image can be copied to another device using the"]
    #[doc = "       ::::zeCommandListAppendImageCopy functions."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clCreateImage"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_IMAGE_DESC_VERSION_CURRENT < desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + desc->flags"]
    #[doc = "         + desc->type"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_IMAGE_FORMAT"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeImageCreate(
        hDevice: ze_device_handle_t,
        desc: *const ze_image_desc_t,
        phImage: *mut ze_image_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes a image object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the image before it is deleted"]
    #[doc = "     - The implementation of this function will immediately free all Host and"]
    #[doc = "       Device allocations associated with this image"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same image handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeImageDestroy(hImage: ze_image_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends an execution and global memory barrier into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - If numWaitEvents is zero, then all previous commands are completed"]
    #[doc = "       prior to the execution of the barrier."]
    #[doc = "     - If numWaitEvents is non-zero, then then all phWaitEvents must be"]
    #[doc = "       signaled prior to the execution of the barrier."]
    #[doc = "     - This command blocks all following commands from beginning until the"]
    #[doc = "       execution of the barrier completes."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkCmdPipelineBarrier**"]
    #[doc = "     - clEnqueueBarrierWithWaitList"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendBarrier(
        hCommandList: ze_command_list_handle_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a global memory ranges barrier into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - If numWaitEvents is zero, then all previous commands are completed"]
    #[doc = "       prior to the execution of the barrier."]
    #[doc = "     - If numWaitEvents is non-zero, then then all phWaitEvents must be"]
    #[doc = "       signaled prior to the execution of the barrier."]
    #[doc = "     - This command blocks all following commands from beginning until the"]
    #[doc = "       execution of the barrier completes."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pRangeSizes`"]
    #[doc = "         + `nullptr == pRanges`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendMemoryRangesBarrier(
        hCommandList: ze_command_list_handle_t,
        numRanges: u32,
        pRangeSizes: *const usize,
        pRanges: *mut *const ::std::os::raw::c_void,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Ensures in-bound writes to the device are globally observable."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This is a special-case system level barrier that can be used to ensure"]
    #[doc = "       global observability of writes; typically needed after a producer"]
    #[doc = "       (e.g., NIC) performs direct writes to the device's memory (e.g.,"]
    #[doc = "       Direct RDMA writes).  This is typically required when the memory"]
    #[doc = "       corresponding to the writes is subsequently accessed from a remote"]
    #[doc = "       device."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    pub fn zeDeviceSystemBarrier(hDevice: ze_device_handle_t) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_module_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_module_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_MODULE_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_module_desc_t"]
pub use self::_ze_module_desc_version_t as ze_module_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported module creation input formats"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_module_format_t {
    #[doc = "< Format is SPIRV IL format"]
    ZE_MODULE_FORMAT_IL_SPIRV = 0,
    #[doc = "< Format is device native format"]
    ZE_MODULE_FORMAT_NATIVE = 1,
}
#[doc = ""]
#[doc = " @brief Supported module creation input formats"]
pub use self::_ze_module_format_t as ze_module_format_t;
#[doc = ""]
#[doc = " @brief Specialization constants - User defined constants"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_constants_t {
    #[doc = "< [in] Number of specialization constants."]
    pub numConstants: u32,
    #[doc = "< [in] Pointer to array of IDs that is sized to numConstants."]
    pub pConstantIds: *const u32,
    #[doc = "< [in] Pointer to array of values that is sized to numConstants."]
    pub pConstantValues: *const u64,
}
#[test]
fn bindgen_test_layout__ze_module_constants_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_constants_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_module_constants_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_constants_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_constants_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_constants_t>())).numConstants as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_constants_t),
            "::",
            stringify!(numConstants)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_constants_t>())).pConstantIds as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_constants_t),
            "::",
            stringify!(pConstantIds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_module_constants_t>())).pConstantValues as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_constants_t),
            "::",
            stringify!(pConstantValues)
        )
    );
}
#[doc = ""]
#[doc = " @brief Module descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_module_desc_t {
    #[doc = "< [in] ::ZE_MODULE_DESC_VERSION_CURRENT"]
    pub version: ze_module_desc_version_t,
    #[doc = "< [in] Module format passed in with pInputModule"]
    pub format: ze_module_format_t,
    #[doc = "< [in] size of input IL or ISA from pInputModule."]
    pub inputSize: usize,
    #[doc = "< [in] pointer to IL or ISA"]
    pub pInputModule: *const u8,
    #[doc = "< [in] string containing compiler flags. See programming guide for build"]
    #[doc = "< flags."]
    pub pBuildFlags: *const ::std::os::raw::c_char,
    #[doc = "< [in] pointer to specialization constants. Valid only for SPIR-V input."]
    #[doc = "< This must be set to nullptr if no specialization constants are"]
    #[doc = "< provided."]
    pub pConstants: *const ze_module_constants_t,
}
#[test]
fn bindgen_test_layout__ze_module_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_module_desc_t>(),
        40usize,
        concat!("Size of: ", stringify!(_ze_module_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_module_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_module_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).format as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).inputSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(inputSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pInputModule as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pInputModule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pBuildFlags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pBuildFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_module_desc_t>())).pConstants as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_module_desc_t),
            "::",
            stringify!(pConstants)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates module object from an input IL or native binary."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Compiles the module for execution on the device."]
    #[doc = "     - The module can only be used on the device on which it was created."]
    #[doc = "     - The module can be copied to other devices within the same driver"]
    #[doc = "       instance by using ::zeModuleGetNativeBinary."]
    #[doc = "     - The following build options are supported:"]
    #[doc = "         + \"-ze-opt-disable\" - Disable optimizations"]
    #[doc = "         + \"-ze-opt-greater-than-4GB-buffer-required\" - Use 64-bit offset"]
    #[doc = "           calculations for buffers."]
    #[doc = "         + \"-ze-opt-large-register-file\" - Increase number of registers"]
    #[doc = "           available to threads."]
    #[doc = "     - A build log can optionally be returned to the caller. The caller is"]
    #[doc = "       responsible for destroying build log using ::zeModuleBuildLogDestroy."]
    #[doc = "     - The module descriptor constants are only supported for SPIR-V"]
    #[doc = "       specialization constants."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == desc->pInputModule`"]
    #[doc = "         + `nullptr == desc->pBuildFlags`"]
    #[doc = "         + `nullptr == desc->pConstants`"]
    #[doc = "         + `nullptr == phModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_MODULE_DESC_VERSION_CURRENT < desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + desc->format"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NATIVE_BINARY"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SIZE"]
    #[doc = "         + `0 == desc->inputSize`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_MODULE_BUILD_FAILURE"]
    pub fn zeModuleCreate(
        hDevice: ze_device_handle_t,
        desc: *const ze_module_desc_t,
        phModule: *mut ze_module_handle_t,
        phBuildLog: *mut ze_module_build_log_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys module"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the module before it is deleted"]
    #[doc = "     - The implementation of this function will immediately free all Host and"]
    #[doc = "       Device allocations associated with this module"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same module handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeModuleDestroy(hModule: ze_module_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys module build log object"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The implementation of this function will immediately free all Host"]
    #[doc = "       allocations associated with this object"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same build log handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = "     - This function can be called before or after ::zeModuleDestroy for the"]
    #[doc = "       associated module."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModuleBuildLog`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeModuleBuildLogDestroy(hModuleBuildLog: ze_module_build_log_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves text string for build log."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The caller can pass nullptr for pBuildLog when querying only for size."]
    #[doc = "     - The caller must provide memory for build log."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModuleBuildLog`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    pub fn zeModuleBuildLogGetString(
        hModuleBuildLog: ze_module_build_log_handle_t,
        pSize: *mut usize,
        pBuildLog: *mut ::std::os::raw::c_char,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve native binary from Module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The native binary output can be cached to disk and new modules can be"]
    #[doc = "       later constructed from the cached copy."]
    #[doc = "     - The native binary will retain debugging information that is associated"]
    #[doc = "       with a module."]
    #[doc = "     - The caller can pass nullptr for pModuleNativeBinary when querying only"]
    #[doc = "       for size."]
    #[doc = "     - The implementation will copy the native binary into a buffer supplied"]
    #[doc = "       by the caller."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    pub fn zeModuleGetNativeBinary(
        hModule: ze_module_handle_t,
        pSize: *mut usize,
        pModuleNativeBinary: *mut u8,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve global variable pointer from Module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pGlobalName`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_GLOBAL_NAME"]
    pub fn zeModuleGetGlobalPointer(
        hModule: ze_module_handle_t,
        pGlobalName: *const ::std::os::raw::c_char,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve all kernel names in the module."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pCount`"]
    pub fn zeModuleGetKernelNames(
        hModule: ze_module_handle_t,
        pCount: *mut u32,
        pNames: *mut *const ::std::os::raw::c_char,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_kernel_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_kernel_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_KERNEL_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_kernel_desc_t"]
pub use self::_ze_kernel_desc_version_t as ze_kernel_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported kernel creation flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_kernel_flag_t {
    #[doc = "< default driver behavior"]
    ZE_KERNEL_FLAG_NONE = 0,
    #[doc = "< force all device allocations to be resident during execution"]
    ZE_KERNEL_FLAG_FORCE_RESIDENCY = 1,
}
#[doc = ""]
#[doc = " @brief Supported kernel creation flags"]
pub use self::_ze_kernel_flag_t as ze_kernel_flag_t;
#[doc = ""]
#[doc = " @brief Kernel descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_kernel_desc_t {
    #[doc = "< [in] ::ZE_KERNEL_DESC_VERSION_CURRENT"]
    pub version: ze_kernel_desc_version_t,
    #[doc = "< [in] creation flags"]
    pub flags: ze_kernel_flag_t,
    #[doc = "< [in] null-terminated name of kernel in module"]
    pub pKernelName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__ze_kernel_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_desc_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_kernel_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_desc_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_ze_kernel_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_desc_t>())).pKernelName as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_desc_t),
            "::",
            stringify!(pKernelName)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Create a kernel object from a module by name"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == desc->pKernelName`"]
    #[doc = "         + `nullptr == phKernel`"]
    #[doc = "         + `nullptr == desc->pKernelName`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_KERNEL_DESC_VERSION_CURRENT < desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + desc->flags"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_NAME"]
    pub fn zeKernelCreate(
        hModule: ze_module_handle_t,
        desc: *const ze_kernel_desc_t,
        phKernel: *mut ze_kernel_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys a kernel object"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - All kernels must be destroyed before the module is destroyed."]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the kernel before it is deleted"]
    #[doc = "     - The implementation of this function will immediately free all Host and"]
    #[doc = "       Device allocations associated with this kernel"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeKernelDestroy(hKernel: ze_kernel_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve a function pointer from a module by name"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The function pointer is unique for the device on which the module was"]
    #[doc = "       created."]
    #[doc = "     - The function pointer is no longer valid if module is destroyed."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hModule`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pFunctionName`"]
    #[doc = "         + `nullptr == pfnFunction`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_FUNCTION_NAME"]
    pub fn zeModuleGetFunctionPointer(
        hModule: ze_module_handle_t,
        pFunctionName: *const ::std::os::raw::c_char,
        pfnFunction: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Set group size for a kernel"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = "     - The implementation will copy the group size information into a command"]
    #[doc = "       list when the function is appended."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_GROUP_SIZE_DIMENSION"]
    pub fn zeKernelSetGroupSize(
        hKernel: ze_kernel_handle_t,
        groupSizeX: u32,
        groupSizeY: u32,
        groupSizeZ: u32,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Query a suggested group size for a kernel given a global size for each"]
    #[doc = "        dimension."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = "     - This function ignores the group size that is set using"]
    #[doc = "       ::zeKernelSetGroupSize."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == groupSizeX`"]
    #[doc = "         + `nullptr == groupSizeY`"]
    #[doc = "         + `nullptr == groupSizeZ`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_GLOBAL_WIDTH_DIMENSION"]
    pub fn zeKernelSuggestGroupSize(
        hKernel: ze_kernel_handle_t,
        globalSizeX: u32,
        globalSizeY: u32,
        globalSizeZ: u32,
        groupSizeX: *mut u32,
        groupSizeY: *mut u32,
        groupSizeZ: *mut u32,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Query a suggested max group count a cooperative kernel."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == totalGroupCount`"]
    pub fn zeKernelSuggestMaxCooperativeGroupCount(
        hKernel: ze_kernel_handle_t,
        totalGroupCount: *mut u32,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Set kernel argument used on kernel launch."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same function handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = "     - The implementation will copy the arguments into a command list when"]
    #[doc = "       the function is appended."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_INDEX"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_ARGUMENT_SIZE"]
    pub fn zeKernelSetArgumentValue(
        hKernel: ze_kernel_handle_t,
        argIndex: u32,
        argSize: usize,
        pArgValue: *const ::std::os::raw::c_void,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Kernel attributes"]
#[doc = ""]
#[doc = " @remarks"]
#[doc = "   _Analogues_"]
#[doc = "     - **cl_kernel_exec_info**"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_kernel_attribute_t {
    #[doc = "< Indicates that the function accesses host allocations indirectly"]
    #[doc = "< (default: false, type: bool_t)"]
    ZE_KERNEL_ATTR_INDIRECT_HOST_ACCESS = 0,
    #[doc = "< Indicates that the function accesses device allocations indirectly"]
    #[doc = "< (default: false, type: bool_t)"]
    ZE_KERNEL_ATTR_INDIRECT_DEVICE_ACCESS = 1,
    #[doc = "< Indicates that the function accesses shared allocations indirectly"]
    #[doc = "< (default: false, type: bool_t)"]
    ZE_KERNEL_ATTR_INDIRECT_SHARED_ACCESS = 2,
    #[doc = "< Declared kernel attributes (i.e. can be specified with __attribute__"]
    #[doc = "< in runtime language). (type: char[]) Returned as a null-terminated"]
    #[doc = "< string and each attribute is separated by a space."]
    #[doc = "< ::zeKernelSetAttribute is not supported for this."]
    ZE_KERNEL_ATTR_SOURCE_ATTRIBUTE = 3,
}
#[doc = ""]
#[doc = " @brief Kernel attributes"]
#[doc = ""]
#[doc = " @remarks"]
#[doc = "   _Analogues_"]
#[doc = "     - **cl_kernel_exec_info**"]
pub use self::_ze_kernel_attribute_t as ze_kernel_attribute_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Sets a kernel attribute"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same function handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clSetKernelExecInfo**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + attr"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE"]
    pub fn zeKernelSetAttribute(
        hKernel: ze_kernel_handle_t,
        attr: ze_kernel_attribute_t,
        size: u32,
        pValue: *const ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Gets a kernel attribute"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same function handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = "     - The caller sets pValue to nullptr when querying only for size."]
    #[doc = "     - The caller must provide memory for pValue querying when querying size."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + attr"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pSize`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_KERNEL_ATTRIBUTE_VALUE"]
    pub fn zeKernelGetAttribute(
        hKernel: ze_kernel_handle_t,
        attr: ze_kernel_attribute_t,
        pSize: *mut u32,
        pValue: *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Sets the preferred Intermediate cache configuration for a kernel."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same kernel handle."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + CacheConfig"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_FEATURE"]
    pub fn zeKernelSetIntermediateCacheConfig(
        hKernel: ze_kernel_handle_t,
        CacheConfig: ze_cache_config_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_kernel_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_kernel_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_KERNEL_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_kernel_properties_t"]
pub use self::_ze_kernel_properties_version_t as ze_kernel_properties_version_t;
#[doc = ""]
#[doc = " @brief Kernel properties"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ze_kernel_properties_t {
    #[doc = "< [in] ::ZE_KERNEL_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_kernel_properties_version_t,
    #[doc = "< [out] Kernel name"]
    pub name: [::std::os::raw::c_char; 256usize],
    #[doc = "< [out] number of kernel arguments."]
    pub numKernelArgs: u32,
    #[doc = "< [out] required group size in the X dimension"]
    pub requiredGroupSizeX: u32,
    #[doc = "< [out] required group size in the Y dimension"]
    pub requiredGroupSizeY: u32,
    #[doc = "< [out] required group size in the Z dimension"]
    pub requiredGroupSizeZ: u32,
}
#[test]
fn bindgen_test_layout__ze_kernel_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_kernel_properties_t>(),
        276usize,
        concat!("Size of: ", stringify!(_ze_kernel_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_kernel_properties_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_kernel_properties_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_properties_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_kernel_properties_t>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).numKernelArgs as *const _ as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(numKernelArgs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredGroupSizeX as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredGroupSizeX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredGroupSizeY as *const _
                as usize
        },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredGroupSizeY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_kernel_properties_t>())).requiredGroupSizeZ as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_kernel_properties_t),
            "::",
            stringify!(requiredGroupSizeZ)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieve kernel properties."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pKernelProperties`"]
    pub fn zeKernelGetProperties(
        hKernel: ze_kernel_handle_t,
        pKernelProperties: *mut ze_kernel_properties_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Kernel dispatch group count."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_group_count_t {
    #[doc = "< [in] number of thread groups in X dimension"]
    pub groupCountX: u32,
    #[doc = "< [in] number of thread groups in Y dimension"]
    pub groupCountY: u32,
    #[doc = "< [in] number of thread groups in Z dimension"]
    pub groupCountZ: u32,
}
#[test]
fn bindgen_test_layout__ze_group_count_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_group_count_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ze_group_count_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_group_count_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_group_count_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_group_count_t>())).groupCountX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_group_count_t),
            "::",
            stringify!(groupCountX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_group_count_t>())).groupCountY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_group_count_t),
            "::",
            stringify!(groupCountY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_group_count_t>())).groupCountZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_group_count_t),
            "::",
            stringify!(groupCountZ)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch kernel over one or more work groups."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pLaunchFuncArgs`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendLaunchKernel(
        hCommandList: ze_command_list_handle_t,
        hKernel: ze_kernel_handle_t,
        pLaunchFuncArgs: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch kernel cooperatively over one or more work groups."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - This may only be used for a command list that are submitted to command"]
    #[doc = "       queue with cooperative flag set."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = "     - Use ::zeKernelSuggestMaxCooperativeGroupCount to recommend max group"]
    #[doc = "       count for device for cooperative functions that device supports."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pLaunchFuncArgs`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendLaunchCooperativeKernel(
        hCommandList: ze_command_list_handle_t,
        hKernel: ze_kernel_handle_t,
        pLaunchFuncArgs: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch kernel over one or more work groups using indirect arguments."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The launch arguments need to be device visible."]
    #[doc = "     - The launch arguments buffer may not be reused until the function has"]
    #[doc = "       completed on the device."]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hKernel`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pLaunchArgumentsBuffer`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendLaunchKernelIndirect(
        hCommandList: ze_command_list_handle_t,
        hKernel: ze_kernel_handle_t,
        pLaunchArgumentsBuffer: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Launch multiple kernels over one or more work groups using an array of"]
    #[doc = "        indirect arguments."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The array of launch arguments need to be device visible."]
    #[doc = "     - The array of launch arguments buffer may not be reused until the"]
    #[doc = "       kernel has completed on the device."]
    #[doc = "     - This may **only** be called for a command list created with command"]
    #[doc = "       queue group ordinal that supports compute."]
    #[doc = "     - This function may **not** be called from simultaneous threads with the"]
    #[doc = "       same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phKernels`"]
    #[doc = "         + `nullptr == pCountBuffer`"]
    #[doc = "         + `nullptr == pLaunchArgumentsBuffer`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendLaunchMultipleKernelsIndirect(
        hCommandList: ze_command_list_handle_t,
        numKernels: u32,
        phKernels: *mut ze_kernel_handle_t,
        pCountBuffer: *const u32,
        pLaunchArgumentsBuffer: *const ze_group_count_t,
        hSignalEvent: ze_event_handle_t,
        numWaitEvents: u32,
        phWaitEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Makes memory resident for the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - If the application does not properly manage residency then the device"]
    #[doc = "       may experience unrecoverable page-faults."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeDeviceMakeMemoryResident(
        hDevice: ze_device_handle_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allows memory to be evicted from the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the memory before it is evicted"]
    #[doc = "     - Memory is always implicitly evicted if it is resident when freed."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeDeviceEvictMemory(
        hDevice: ze_device_handle_t,
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Makes image resident for the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - If the application does not properly manage residency then the device"]
    #[doc = "       may experience unrecoverable page-faults."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeDeviceMakeImageResident(
        hDevice: ze_device_handle_t,
        hImage: ze_image_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allows image to be evicted from the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the memory before it is evicted"]
    #[doc = "     - An image is always implicitly evicted if it is resident when"]
    #[doc = "       destroyed."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "         + `nullptr == hImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeDeviceEvictImage(
        hDevice: ze_device_handle_t,
        hImage: ze_image_handle_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_event_pool_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_event_pool_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_EVENT_POOL_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_event_pool_desc_t"]
pub use self::_ze_event_pool_desc_version_t as ze_event_pool_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported event pool creation flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_event_pool_flag_t {
    #[doc = "< signals and waits visible to the entire device and peer devices"]
    ZE_EVENT_POOL_FLAG_DEFAULT = 0,
    #[doc = "< signals and waits are also visible to host"]
    ZE_EVENT_POOL_FLAG_HOST_VISIBLE = 1,
    #[doc = "< signals and waits may be shared across processes"]
    ZE_EVENT_POOL_FLAG_IPC = 2,
    #[doc = "< Indicates all events in pool will contain timestamp information that"]
    #[doc = "< can be queried using ::zeEventGetTimestamp"]
    ZE_EVENT_POOL_FLAG_TIMESTAMP = 4,
}
#[doc = ""]
#[doc = " @brief Supported event pool creation flags"]
pub use self::_ze_event_pool_flag_t as ze_event_pool_flag_t;
#[doc = ""]
#[doc = " @brief Event pool descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_pool_desc_t {
    #[doc = "< [in] ::ZE_EVENT_POOL_DESC_VERSION_CURRENT"]
    pub version: ze_event_pool_desc_version_t,
    #[doc = "< [in] creation flags"]
    pub flags: ze_event_pool_flag_t,
    #[doc = "< [in] number of events within the pool"]
    pub count: u32,
}
#[test]
fn bindgen_test_layout__ze_event_pool_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_pool_desc_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ze_event_pool_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_pool_desc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_event_pool_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_pool_desc_t>())).count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_pool_desc_t),
            "::",
            stringify!(count)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a pool for a set of event(s) for the driver"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_EVENT_POOL_DESC_VERSION_CURRENT < desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + desc->flags"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeEventPoolCreate(
        hDriver: ze_driver_handle_t,
        desc: *const ze_event_pool_desc_t,
        numDevices: u32,
        phDevices: *mut ze_device_handle_t,
        phEventPool: *mut ze_event_pool_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes an event pool object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for destroying all event handles"]
    #[doc = "       created from the pool before destroying the pool itself"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the any event within the pool before it is"]
    #[doc = "       deleted"]
    #[doc = "     - The implementation of this function will immediately free all Host and"]
    #[doc = "       Device allocations associated with this event pool"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same event pool handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeEventPoolDestroy(hEventPool: ze_event_pool_handle_t) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_event_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_event_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_EVENT_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_event_desc_t"]
pub use self::_ze_event_desc_version_t as ze_event_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported event scope flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_event_scope_flag_t {
    #[doc = "< execution synchronization only; no cache hierarchies are flushed or"]
    #[doc = "< invalidated"]
    ZE_EVENT_SCOPE_FLAG_NONE = 0,
    #[doc = "< cache hierarchies are flushed or invalidated sufficient for local"]
    #[doc = "< sub-device access"]
    ZE_EVENT_SCOPE_FLAG_SUBDEVICE = 1,
    #[doc = "< cache hierarchies are flushed or invalidated sufficient for global"]
    #[doc = "< device access and peer device access"]
    ZE_EVENT_SCOPE_FLAG_DEVICE = 2,
    #[doc = "< cache hierarchies are flushed or invalidated sufficient for device and"]
    #[doc = "< host access"]
    ZE_EVENT_SCOPE_FLAG_HOST = 4,
}
#[doc = ""]
#[doc = " @brief Supported event scope flags"]
pub use self::_ze_event_scope_flag_t as ze_event_scope_flag_t;
#[doc = ""]
#[doc = " @brief Event descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_event_desc_t {
    #[doc = "< [in] ::ZE_EVENT_DESC_VERSION_CURRENT"]
    pub version: ze_event_desc_version_t,
    #[doc = "< [in] index of the event within the pool; must be less-than the count"]
    #[doc = "< specified during pool creation"]
    pub index: u32,
    #[doc = "< [in] defines the scope of relevant cache hierarchies to flush on a"]
    #[doc = "< signal action before the event is triggered"]
    pub signal: ze_event_scope_flag_t,
    #[doc = "< [in] defines the scope of relevant cache hierarchies to invalidate on"]
    #[doc = "< a wait action after the event is complete"]
    pub wait: ze_event_scope_flag_t,
}
#[test]
fn bindgen_test_layout__ze_event_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_event_desc_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_event_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_event_desc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_event_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).signal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_event_desc_t>())).wait as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_event_desc_t),
            "::",
            stringify!(wait)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates an event on the device."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Multiple events cannot be created using the same location within the"]
    #[doc = "       same pool."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clCreateUserEvent**"]
    #[doc = "     - vkCreateEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_EVENT_DESC_VERSION_CURRENT < desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + desc->signal"]
    #[doc = "         + desc->wait"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    pub fn zeEventCreate(
        hEventPool: ze_event_pool_handle_t,
        desc: *const ze_event_desc_t,
        phEvent: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes an event object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the event before it is deleted"]
    #[doc = "     - The implementation of this function will immediately free all Host and"]
    #[doc = "       Device allocations associated with this event"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same event handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clReleaseEvent**"]
    #[doc = "     - vkDestroyEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeEventDestroy(hEvent: ze_event_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Gets an IPC event pool handle for the specified event handle that can"]
    #[doc = "        be shared with another process."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phIpc`"]
    pub fn zeEventPoolGetIpcHandle(
        hEventPool: ze_event_pool_handle_t,
        phIpc: *mut ze_ipc_event_pool_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Opens an IPC event pool handle to retrieve an event pool handle from"]
    #[doc = "        another process."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The event handle in this process should not be freed with"]
    #[doc = "       ::zeEventPoolDestroy, but rather with ::zeEventPoolCloseIpcHandle."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phEventPool`"]
    pub fn zeEventPoolOpenIpcHandle(
        hDriver: ze_driver_handle_t,
        hIpc: ze_ipc_event_pool_handle_t,
        phEventPool: *mut ze_event_pool_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Closes an IPC event handle in the current process."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Closes an IPC event handle by destroying events that were opened in"]
    #[doc = "       this process using ::zeEventPoolOpenIpcHandle."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same event pool handle."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEventPool`"]
    pub fn zeEventPoolCloseIpcHandle(hEventPool: ze_event_pool_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends a signal of the event from the device into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clSetUserEventStatus**"]
    #[doc = "     - vkCmdSetEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendSignalEvent(
        hCommandList: ze_command_list_handle_t,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Appends wait on event(s) on the device into a command list."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == phEvents`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendWaitOnEvents(
        hCommandList: ze_command_list_handle_t,
        numEvents: u32,
        phEvents: *mut ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Signals a event from host."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clSetUserEventStatus"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeEventHostSignal(hEvent: ze_event_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief The current host thread waits on an event to be signaled."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clWaitForEvents"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + timeout expired"]
    pub fn zeEventHostSynchronize(hEvent: ze_event_handle_t, timeout: u32) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries an event object's status."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clGetEventInfo**"]
    #[doc = "     - vkGetEventStatus"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + not signaled"]
    pub fn zeEventQueryStatus(hEvent: ze_event_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Reset an event back to not signaled state"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - vkResetEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendEventReset(
        hCommandList: ze_command_list_handle_t,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Reset an event back to not signaled state"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - vkResetEvent"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeEventHostReset(hEvent: ze_event_handle_t) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported timestamp types"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_event_timestamp_type_t {
    #[doc = "< wall-clock time start in GPU clocks for event. Data is uint64_t."]
    ZE_EVENT_TIMESTAMP_GLOBAL_START = 0,
    #[doc = "< wall-clock time end in GPU clocks for event.Data is uint64_t."]
    ZE_EVENT_TIMESTAMP_GLOBAL_END = 1,
    #[doc = "< context time start in GPU clocks for event.  Only includes time while"]
    #[doc = "< HW context is actively running on GPU. Data is uint64_t."]
    ZE_EVENT_TIMESTAMP_CONTEXT_START = 2,
    #[doc = "< context time end in GPU clocks for event.  Only includes time while HW"]
    #[doc = "< context is actively running on GPU. Data is uint64_t."]
    ZE_EVENT_TIMESTAMP_CONTEXT_END = 3,
}
#[doc = ""]
#[doc = " @brief Supported timestamp types"]
pub use self::_ze_event_timestamp_type_t as ze_event_timestamp_type_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Query timestamp information associated with an event. Event must come"]
    #[doc = "        from an event pool that was created using"]
    #[doc = "        ::ZE_EVENT_POOL_FLAG_TIMESTAMP flag."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hEvent`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + timestampType"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeEventGetTimestamp(
        hEvent: ze_event_handle_t,
        timestampType: ze_event_timestamp_type_t,
        dstptr: *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_sampler_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_sampler_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_SAMPLER_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_sampler_desc_t"]
pub use self::_ze_sampler_desc_version_t as ze_sampler_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Sampler addressing modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_sampler_address_mode_t {
    #[doc = "< No coordinate modifications for out-of-bounds image access."]
    ZE_SAMPLER_ADDRESS_MODE_NONE = 0,
    #[doc = "< Out-of-bounds coordinates are wrapped back around."]
    ZE_SAMPLER_ADDRESS_MODE_REPEAT = 1,
    #[doc = "< Out-of-bounds coordinates are clamped to edge."]
    ZE_SAMPLER_ADDRESS_MODE_CLAMP = 2,
    #[doc = "< Out-of-bounds coordinates are clamped to border color which is (0.0f,"]
    #[doc = "< 0.0f, 0.0f, 0.0f) if image format swizzle contains alpha, otherwise"]
    #[doc = "< (0.0f, 0.0f, 0.0f, 1.0f)."]
    ZE_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    #[doc = "< Out-of-bounds coordinates are mirrored starting from edge."]
    ZE_SAMPLER_ADDRESS_MODE_MIRROR = 4,
}
#[doc = ""]
#[doc = " @brief Sampler addressing modes"]
pub use self::_ze_sampler_address_mode_t as ze_sampler_address_mode_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Sampler filtering modes"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_sampler_filter_mode_t {
    #[doc = "< No coordinate modifications for out of bounds image access."]
    ZE_SAMPLER_FILTER_MODE_NEAREST = 0,
    #[doc = "< Out-of-bounds coordinates are wrapped back around."]
    ZE_SAMPLER_FILTER_MODE_LINEAR = 1,
}
#[doc = ""]
#[doc = " @brief Sampler filtering modes"]
pub use self::_ze_sampler_filter_mode_t as ze_sampler_filter_mode_t;
#[doc = ""]
#[doc = " @brief Sampler descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_sampler_desc_t {
    #[doc = "< [in] ::ZE_SAMPLER_DESC_VERSION_CURRENT"]
    pub version: ze_sampler_desc_version_t,
    #[doc = "< [in] Sampler addressing mode to determine how out-of-bounds"]
    #[doc = "< coordinates are handled."]
    pub addressMode: ze_sampler_address_mode_t,
    #[doc = "< [in] Sampler filter mode to determine how samples are filtered."]
    pub filterMode: ze_sampler_filter_mode_t,
    #[doc = "< [in] Are coordinates normalized [0, 1] or not."]
    pub isNormalized: ze_bool_t,
}
#[test]
fn bindgen_test_layout__ze_sampler_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_sampler_desc_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_sampler_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_sampler_desc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_sampler_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).addressMode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(addressMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).filterMode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(filterMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_sampler_desc_t>())).isNormalized as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_sampler_desc_t),
            "::",
            stringify!(isNormalized)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates sampler object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The sampler can only be used on the device on which it was created."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phSampler`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_SAMPLER_DESC_VERSION_CURRENT < desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + desc->addressMode"]
    #[doc = "         + desc->filterMode"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    pub fn zeSamplerCreate(
        hDevice: ze_device_handle_t,
        desc: *const ze_sampler_desc_t,
        phSampler: *mut ze_sampler_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Destroys sampler object"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the sampler before it is deleted"]
    #[doc = "     - The implementation of this function will immediately free all Host and"]
    #[doc = "       Device allocations associated with this module"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same sampler handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hSampler`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeSamplerDestroy(hSampler: ze_sampler_handle_t) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_device_mem_alloc_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_mem_alloc_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_DEVICE_MEM_ALLOC_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_device_mem_alloc_desc_t"]
pub use self::_ze_device_mem_alloc_desc_version_t as ze_device_mem_alloc_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported memory allocation flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_device_mem_alloc_flag_t {
    #[doc = "< implicit default behavior; uses driver-based heuristics"]
    ZE_DEVICE_MEM_ALLOC_FLAG_DEFAULT = 0,
    #[doc = "< device should cache allocation"]
    ZE_DEVICE_MEM_ALLOC_FLAG_BIAS_CACHED = 1,
    #[doc = "< device should not cache allocation (UC)"]
    ZE_DEVICE_MEM_ALLOC_FLAG_BIAS_UNCACHED = 2,
}
#[doc = ""]
#[doc = " @brief Supported memory allocation flags"]
pub use self::_ze_device_mem_alloc_flag_t as ze_device_mem_alloc_flag_t;
#[doc = ""]
#[doc = " @brief Device mem alloc descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_device_mem_alloc_desc_t {
    #[doc = "< [in] ::ZE_DEVICE_MEM_ALLOC_DESC_VERSION_CURRENT"]
    pub version: ze_device_mem_alloc_desc_version_t,
    #[doc = "< [in] flags specifying additional allocation controls"]
    pub flags: ze_device_mem_alloc_flag_t,
    #[doc = "< [in] ordinal of the device's local memory to allocate from;"]
    #[doc = "< must be less than the count returned from ::zeDeviceGetMemoryProperties"]
    pub ordinal: u32,
}
#[test]
fn bindgen_test_layout__ze_device_mem_alloc_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_device_mem_alloc_desc_t>(),
        12usize,
        concat!("Size of: ", stringify!(_ze_device_mem_alloc_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_device_mem_alloc_desc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_device_mem_alloc_desc_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_device_mem_alloc_desc_t>())).ordinal as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_device_mem_alloc_desc_t),
            "::",
            stringify!(ordinal)
        )
    );
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_host_mem_alloc_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_host_mem_alloc_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_HOST_MEM_ALLOC_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_host_mem_alloc_desc_t"]
pub use self::_ze_host_mem_alloc_desc_version_t as ze_host_mem_alloc_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported host memory allocation flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_host_mem_alloc_flag_t {
    #[doc = "< implicit default behavior; uses driver-based heuristics"]
    ZE_HOST_MEM_ALLOC_FLAG_DEFAULT = 0,
    #[doc = "< host should cache allocation"]
    ZE_HOST_MEM_ALLOC_FLAG_BIAS_CACHED = 1,
    #[doc = "< host should not cache allocation (UC)"]
    ZE_HOST_MEM_ALLOC_FLAG_BIAS_UNCACHED = 2,
    #[doc = "< host memory should be allocated write-combined (WC)"]
    ZE_HOST_MEM_ALLOC_FLAG_BIAS_WRITE_COMBINED = 4,
}
#[doc = ""]
#[doc = " @brief Supported host memory allocation flags"]
pub use self::_ze_host_mem_alloc_flag_t as ze_host_mem_alloc_flag_t;
#[doc = ""]
#[doc = " @brief Host mem alloc descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_host_mem_alloc_desc_t {
    #[doc = "< [in] ::ZE_HOST_MEM_ALLOC_DESC_VERSION_CURRENT"]
    pub version: ze_host_mem_alloc_desc_version_t,
    #[doc = "< [in] flags specifying additional allocation controls"]
    pub flags: ze_host_mem_alloc_flag_t,
}
#[test]
fn bindgen_test_layout__ze_host_mem_alloc_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_host_mem_alloc_desc_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_host_mem_alloc_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_host_mem_alloc_desc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_host_mem_alloc_desc_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_host_mem_alloc_desc_t>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_host_mem_alloc_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_host_mem_alloc_desc_t>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_host_mem_alloc_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allocates memory that is shared between the host and one or more"]
    #[doc = "        devices"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Shared allocations share ownership between the host and one or more"]
    #[doc = "       devices."]
    #[doc = "     - Shared allocations may optionally be associated with a device by"]
    #[doc = "       passing a handle to the device."]
    #[doc = "     - Devices supporting only single-device shared access capabilities may"]
    #[doc = "       access shared memory associated with the device."]
    #[doc = "       For these devices, ownership of the allocation is shared between the"]
    #[doc = "       host and the associated device only."]
    #[doc = "     - Passing nullptr as the device handle does not associate the shared"]
    #[doc = "       allocation with any device."]
    #[doc = "       For allocations with no associated device, ownership of the allocation"]
    #[doc = "       is shared between the host and all devices supporting cross-device"]
    #[doc = "       shared access capabilities."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == device_desc`"]
    #[doc = "         + `nullptr == host_desc`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_DEVICE_MEM_ALLOC_DESC_VERSION_CURRENT < device_desc->version`"]
    #[doc = "         + `::ZE_HOST_MEM_ALLOC_DESC_VERSION_CURRENT < host_desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + device_desc->flags"]
    #[doc = "         + host_desc->flags"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeDriverAllocSharedMem(
        hDriver: ze_driver_handle_t,
        device_desc: *const ze_device_mem_alloc_desc_t,
        host_desc: *const ze_host_mem_alloc_desc_t,
        size: usize,
        alignment: usize,
        hDevice: ze_device_handle_t,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allocates memory specific to a device"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A device allocation is owned by a specific device."]
    #[doc = "     - In general, a device allocation may only be accessed by the device"]
    #[doc = "       that owns it."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == device_desc`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_DEVICE_MEM_ALLOC_DESC_VERSION_CURRENT < device_desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + device_desc->flags"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeDriverAllocDeviceMem(
        hDriver: ze_driver_handle_t,
        device_desc: *const ze_device_mem_alloc_desc_t,
        size: usize,
        alignment: usize,
        hDevice: ze_device_handle_t,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Allocates host memory"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - A host allocation is owned by the host process."]
    #[doc = "     - Host allocations are accessible by the host and all devices within the"]
    #[doc = "       driver driver."]
    #[doc = "     - Host allocations are frequently used as staging areas to transfer data"]
    #[doc = "       to or from devices."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == host_desc`"]
    #[doc = "         + `nullptr == pptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_HOST_MEM_ALLOC_DESC_VERSION_CURRENT < host_desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + host_desc->flags"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_SIZE"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_ALIGNMENT"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeDriverAllocHostMem(
        hDriver: ze_driver_handle_t,
        host_desc: *const ze_host_mem_alloc_desc_t,
        size: usize,
        alignment: usize,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Frees allocated host memory, device memory, or shared memory"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the memory before it is freed"]
    #[doc = "     - The implementation of this function will immediately free all Host and"]
    #[doc = "       Device allocations associated with this memory"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same pointer."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeDriverFreeMem(
        hDriver: ze_driver_handle_t,
        ptr: *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_memory_allocation_properties_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_memory_allocation_properties_version_t {
    #[doc = "< version 0.91"]
    ZE_MEMORY_ALLOCATION_PROPERTIES_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_memory_allocation_properties_t"]
pub use self::_ze_memory_allocation_properties_version_t as ze_memory_allocation_properties_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Memory allocation type"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_memory_type_t {
    #[doc = "< the memory pointed to is of unknown type"]
    ZE_MEMORY_TYPE_UNKNOWN = 0,
    #[doc = "< the memory pointed to is a host allocation"]
    ZE_MEMORY_TYPE_HOST = 1,
    #[doc = "< the memory pointed to is a device allocation"]
    ZE_MEMORY_TYPE_DEVICE = 2,
    #[doc = "< the memory pointed to is a shared ownership allocation"]
    ZE_MEMORY_TYPE_SHARED = 3,
}
#[doc = ""]
#[doc = " @brief Memory allocation type"]
pub use self::_ze_memory_type_t as ze_memory_type_t;
#[doc = ""]
#[doc = " @brief Memory allocation properties queried using"]
#[doc = "        ::zeDriverGetMemAllocProperties"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_memory_allocation_properties_t {
    #[doc = "< [in] ::ZE_MEMORY_ALLOCATION_PROPERTIES_VERSION_CURRENT"]
    pub version: ze_memory_allocation_properties_version_t,
    #[doc = "< [out] type of allocated memory"]
    pub type_: ze_memory_type_t,
    #[doc = "< [out] identifier for this allocation"]
    pub id: u64,
}
#[test]
fn bindgen_test_layout__ze_memory_allocation_properties_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_memory_allocation_properties_t>(),
        16usize,
        concat!("Size of: ", stringify!(_ze_memory_allocation_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_memory_allocation_properties_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ze_memory_allocation_properties_t)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).type_ as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ze_memory_allocation_properties_t>())).id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_memory_allocation_properties_t),
            "::",
            stringify!(id)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves attributes of a memory allocation"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == pMemAllocProperties`"]
    pub fn zeDriverGetMemAllocProperties(
        hDriver: ze_driver_handle_t,
        ptr: *const ::std::os::raw::c_void,
        pMemAllocProperties: *mut ze_memory_allocation_properties_t,
        phDevice: *mut ze_device_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Retrieves the base address and/or size of an allocation"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeDriverGetMemAddressRange(
        hDriver: ze_driver_handle_t,
        ptr: *const ::std::os::raw::c_void,
        pBase: *mut *mut ::std::os::raw::c_void,
        pSize: *mut usize,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates an IPC memory handle for the specified allocation in the"]
    #[doc = "        sending process"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Takes a pointer to the base of a device memory allocation and exports"]
    #[doc = "       it for use in another process."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == pIpcHandle`"]
    pub fn zeDriverGetMemIpcHandle(
        hDriver: ze_driver_handle_t,
        ptr: *const ::std::os::raw::c_void,
        pIpcHandle: *mut ze_ipc_mem_handle_t,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported IPC memory flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_ipc_memory_flag_t {
    #[doc = "< No special flags"]
    ZE_IPC_MEMORY_FLAG_NONE = 0,
}
#[doc = ""]
#[doc = " @brief Supported IPC memory flags"]
pub use self::_ze_ipc_memory_flag_t as ze_ipc_memory_flag_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Opens an IPC memory handle to retrieve a device pointer in a receiving"]
    #[doc = "        process"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Takes an IPC memory handle from a sending process and associates it"]
    #[doc = "       with a device pointer usable in this process."]
    #[doc = "     - The device pointer in this process should not be freed with"]
    #[doc = "       ::zeDriverFreeMem, but rather with ::zeDriverCloseMemIpcHandle."]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + flags"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == pptr`"]
    pub fn zeDriverOpenMemIpcHandle(
        hDriver: ze_driver_handle_t,
        hDevice: ze_device_handle_t,
        handle: ze_ipc_mem_handle_t,
        flags: ze_ipc_memory_flag_t,
        pptr: *mut *mut ::std::os::raw::c_void,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Closes an IPC memory handle in a receiving process"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Closes an IPC memory handle by unmapping memory that was opened in"]
    #[doc = "       this process using ::zeDriverOpenMemIpcHandle."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same pointer."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hDriver`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeDriverCloseMemIpcHandle(
        hDriver: ze_driver_handle_t,
        ptr: *const ::std::os::raw::c_void,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief API version of ::ze_fence_desc_t"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_fence_desc_version_t {
    #[doc = "< version 0.91"]
    ZE_FENCE_DESC_VERSION_CURRENT = 91,
}
#[doc = ""]
#[doc = " @brief API version of ::ze_fence_desc_t"]
pub use self::_ze_fence_desc_version_t as ze_fence_desc_version_t;
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported fence creation flags"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_fence_flag_t {
    #[doc = "< default behavior"]
    ZE_FENCE_FLAG_NONE = 0,
}
#[doc = ""]
#[doc = " @brief Supported fence creation flags"]
pub use self::_ze_fence_flag_t as ze_fence_flag_t;
#[doc = ""]
#[doc = " @brief Fence descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_fence_desc_t {
    #[doc = "< [in] ::ZE_FENCE_DESC_VERSION_CURRENT"]
    pub version: ze_fence_desc_version_t,
    #[doc = "< [in] creation flags"]
    pub flags: ze_fence_flag_t,
}
#[test]
fn bindgen_test_layout__ze_fence_desc_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_fence_desc_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ze_fence_desc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_fence_desc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_fence_desc_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_fence_desc_t>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_desc_t),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_fence_desc_t>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_fence_desc_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Creates a fence object on the device's command queue."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkCreateFence**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandQueue`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == desc`"]
    #[doc = "         + `nullptr == phFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNSUPPORTED_VERSION"]
    #[doc = "         + `::ZE_FENCE_DESC_VERSION_CURRENT < desc->version`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + desc->flags"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY"]
    #[doc = "     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY"]
    pub fn zeFenceCreate(
        hCommandQueue: ze_command_queue_handle_t,
        desc: *const ze_fence_desc_t,
        phFence: *mut ze_fence_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Deletes a fence object."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application is responsible for making sure the device is not"]
    #[doc = "       currently referencing the fence before it is deleted"]
    #[doc = "     - The implementation of this function will immediately free all Host and"]
    #[doc = "       Device allocations associated with this fence"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same fence handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkDestroyFence**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_HANDLE_OBJECT_IN_USE"]
    pub fn zeFenceDestroy(hFence: ze_fence_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief The current host thread waits on a fence to be signaled."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkWaitForFences**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + timeout expired"]
    pub fn zeFenceHostSynchronize(hFence: ze_fence_handle_t, timeout: u32) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Queries a fence object's status."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkGetFenceStatus**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_NOT_READY"]
    #[doc = "         + not signaled"]
    pub fn zeFenceQueryStatus(hFence: ze_fence_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Reset a fence back to the not signaled state."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may call this function from simultaneous threads."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **vkResetFences**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hFence`"]
    pub fn zeFenceReset(hFence: ze_fence_handle_t) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies host, device, or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The memory pointed to by both srcptr and dstptr must be accessible by"]
    #[doc = "       the device on which the command list is created."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clEnqueueCopyBuffer**"]
    #[doc = "     - **clEnqueueReadBuffer**"]
    #[doc = "     - **clEnqueueWriteBuffer**"]
    #[doc = "     - **clEnqueueSVMMemcpy**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendMemoryCopy(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        srcptr: *const ::std::os::raw::c_void,
        size: usize,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Initializes host, device, or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The memory pointed to by dstptr must be accessible by the device on"]
    #[doc = "       which the command list is created."]
    #[doc = "     - The value to initialize memory to is described by the pattern and the"]
    #[doc = "       pattern size."]
    #[doc = "     - The pattern size must be a power of two."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clEnqueueFillBuffer**"]
    #[doc = "     - **clEnqueueSVMMemFill**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "         + `nullptr == pattern`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendMemoryFill(
        hCommandList: ze_command_list_handle_t,
        ptr: *mut ::std::os::raw::c_void,
        pattern: *const ::std::os::raw::c_void,
        pattern_size: usize,
        size: usize,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Copy region descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_copy_region_t {
    #[doc = "< [in] The origin x offset for region in bytes"]
    pub originX: u32,
    #[doc = "< [in] The origin y offset for region in rows"]
    pub originY: u32,
    #[doc = "< [in] The origin z offset for region in slices"]
    pub originZ: u32,
    #[doc = "< [in] The region width relative to origin in bytes"]
    pub width: u32,
    #[doc = "< [in] The region height relative to origin in rows"]
    pub height: u32,
    #[doc = "< [in] The region depth relative to origin in slices. Set this to 0 for"]
    #[doc = "< 2D copy."]
    pub depth: u32,
}
#[test]
fn bindgen_test_layout__ze_copy_region_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_copy_region_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_copy_region_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_copy_region_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_copy_region_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).originX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(originX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).originY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(originY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).originZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(originZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_copy_region_t>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_copy_region_t),
            "::",
            stringify!(depth)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies a region from a 2D or 3D array of host, device, or shared"]
    #[doc = "        memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The memory pointed to by both srcptr and dstptr must be accessible by"]
    #[doc = "       the device on which the command list is created."]
    #[doc = "     - The region width, height, and depth for both src and dst must be same."]
    #[doc = "       The origins can be different."]
    #[doc = "     - The src and dst regions cannot be overlapping."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "         + `nullptr == dstRegion`"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "         + `nullptr == srcRegion`"]
    #[doc = "     - ::ZE_RESULT_ERROR_OVERLAPPING_REGIONS"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendMemoryCopyRegion(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        dstRegion: *const ze_copy_region_t,
        dstPitch: u32,
        dstSlicePitch: u32,
        srcptr: *const ::std::os::raw::c_void,
        srcRegion: *const ze_copy_region_t,
        srcPitch: u32,
        srcSlicePitch: u32,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies a image."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - **clEnqueueCopyImage**"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDstImage`"]
    #[doc = "         + `nullptr == hSrcImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendImageCopy(
        hCommandList: ze_command_list_handle_t,
        hDstImage: ze_image_handle_t,
        hSrcImage: ze_image_handle_t,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
#[doc = ""]
#[doc = " @brief Region descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ze_image_region_t {
    #[doc = "< [in] The origin x offset for region in pixels"]
    pub originX: u32,
    #[doc = "< [in] The origin y offset for region in pixels"]
    pub originY: u32,
    #[doc = "< [in] The origin z offset for region in pixels"]
    pub originZ: u32,
    #[doc = "< [in] The region width relative to origin in pixels"]
    pub width: u32,
    #[doc = "< [in] The region height relative to origin in pixels"]
    pub height: u32,
    #[doc = "< [in] The region depth relative to origin. For 1D or 2D images, set"]
    #[doc = "< this to 1."]
    pub depth: u32,
}
#[test]
fn bindgen_test_layout__ze_image_region_t() {
    assert_eq!(
        ::std::mem::size_of::<_ze_image_region_t>(),
        24usize,
        concat!("Size of: ", stringify!(_ze_image_region_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ze_image_region_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ze_image_region_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).originX as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(originX)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).originY as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(originY)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).originZ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(originZ)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ze_image_region_t>())).depth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ze_image_region_t),
            "::",
            stringify!(depth)
        )
    );
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies a region of a image to another image."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The region width and height for both src and dst must be same. The"]
    #[doc = "       origins can be different."]
    #[doc = "     - The src and dst regions cannot be overlapping."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDstImage`"]
    #[doc = "         + `nullptr == hSrcImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    #[doc = "     - ::ZE_RESULT_ERROR_OVERLAPPING_REGIONS"]
    pub fn zeCommandListAppendImageCopyRegion(
        hCommandList: ze_command_list_handle_t,
        hDstImage: ze_image_handle_t,
        hSrcImage: ze_image_handle_t,
        pDstRegion: *const ze_image_region_t,
        pSrcRegion: *const ze_image_region_t,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies from a image to device or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The memory pointed to by dstptr must be accessible by the device on"]
    #[doc = "       which the command list is created."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clEnqueueReadImage"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hSrcImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == dstptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendImageCopyToMemory(
        hCommandList: ze_command_list_handle_t,
        dstptr: *mut ::std::os::raw::c_void,
        hSrcImage: ze_image_handle_t,
        pSrcRegion: *const ze_image_region_t,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Copies to a image from device or shared memory."]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - The memory pointed to by srcptr must be accessible by the device on"]
    #[doc = "       which the command list is created."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clEnqueueWriteImage"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDstImage`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == srcptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT"]
    pub fn zeCommandListAppendImageCopyFromMemory(
        hCommandList: ze_command_list_handle_t,
        hDstImage: ze_image_handle_t,
        srcptr: *const ::std::os::raw::c_void,
        pDstRegion: *const ze_image_region_t,
        hEvent: ze_event_handle_t,
    ) -> ze_result_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " @brief Asynchronously prefetches shared memory to the device associated with"]
    #[doc = "        the specified command list"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - This is a hint to improve performance only and is not required for"]
    #[doc = "       correctness."]
    #[doc = "     - Only prefetching to the device associated with the specified command"]
    #[doc = "       list is supported."]
    #[doc = "       Prefetching to the host or to a peer device is not supported."]
    #[doc = "     - Prefetching may not be supported for all allocation types for all devices."]
    #[doc = "       If memory prefetching is not supported for the specified memory range"]
    #[doc = "       the prefetch hint may be ignored."]
    #[doc = "     - Prefetching may only be supported at a device-specific granularity,"]
    #[doc = "       such as at a page boundary."]
    #[doc = "       In this case, the memory range may be expanded such that the start and"]
    #[doc = "       end of the range satisfy granularity requirements."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @remarks"]
    #[doc = "   _Analogues_"]
    #[doc = "     - clEnqueueSVMMigrateMem"]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    pub fn zeCommandListAppendMemoryPrefetch(
        hCommandList: ze_command_list_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ze_result_t;
}
#[repr(i32)]
#[doc = ""]
#[doc = " @brief Supported memory advice hints"]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _ze_memory_advice_t {
    #[doc = "< hint that memory will be read from frequently and written to rarely"]
    ZE_MEMORY_ADVICE_SET_READ_MOSTLY = 0,
    #[doc = "< removes the affect of ::ZE_MEMORY_ADVICE_SET_READ_MOSTLY"]
    ZE_MEMORY_ADVICE_CLEAR_READ_MOSTLY = 1,
    #[doc = "< hint that the preferred memory location is the specified device"]
    ZE_MEMORY_ADVICE_SET_PREFERRED_LOCATION = 2,
    #[doc = "< removes the affect of ::ZE_MEMORY_ADVICE_SET_PREFERRED_LOCATION"]
    ZE_MEMORY_ADVICE_CLEAR_PREFERRED_LOCATION = 3,
    #[doc = "< hint that memory will be accessed by the specified device"]
    ZE_MEMORY_ADVICE_SET_ACCESSED_BY = 4,
    #[doc = "< removes the affect of ::ZE_MEMORY_ADVICE_SET_ACCESSED_BY"]
    ZE_MEMORY_ADVICE_CLEAR_ACCESSED_BY = 5,
    #[doc = "< hints that memory will mostly be accessed non-atomically"]
    ZE_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY = 6,
    #[doc = "< removes the affect of ::ZE_MEMORY_ADVICE_SET_NON_ATOMIC_MOSTLY"]
    ZE_MEMORY_ADVICE_CLEAR_NON_ATOMIC_MOSTLY = 7,
    #[doc = "< hints that memory should be cached"]
    ZE_MEMORY_ADVICE_BIAS_CACHED = 8,
    #[doc = "< hints that memory should be not be cached"]
    ZE_MEMORY_ADVICE_BIAS_UNCACHED = 9,
}
#[doc = ""]
#[doc = " @brief Supported memory advice hints"]
pub use self::_ze_memory_advice_t as ze_memory_advice_t;
extern "C" {
    #[doc = ""]
    #[doc = " @brief Provides advice about the use of a shared memory range"]
    #[doc = ""]
    #[doc = " @details"]
    #[doc = "     - Memory advice is a performance hint only and is not required for"]
    #[doc = "       functional correctness."]
    #[doc = "     - Memory advice can be used to override driver heuristics to explicitly"]
    #[doc = "       control shared memory behavior."]
    #[doc = "     - Not all memory advice hints may be supported for all allocation types"]
    #[doc = "       for all devices."]
    #[doc = "       If a memory advice hint is not supported by the device it will be ignored."]
    #[doc = "     - Memory advice may only be supported at a device-specific granularity,"]
    #[doc = "       such as at a page boundary."]
    #[doc = "       In this case, the memory range may be expanded such that the start and"]
    #[doc = "       end of the range satisfy granularity requirements."]
    #[doc = "     - The application may **not** call this function from simultaneous"]
    #[doc = "       threads with the same command list handle."]
    #[doc = "     - The implementation of this function should be lock-free."]
    #[doc = ""]
    #[doc = " @returns"]
    #[doc = "     - ::ZE_RESULT_SUCCESS"]
    #[doc = "     - ::ZE_RESULT_ERROR_UNINITIALIZED"]
    #[doc = "     - ::ZE_RESULT_ERROR_DEVICE_LOST"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE"]
    #[doc = "         + `nullptr == hCommandList`"]
    #[doc = "         + `nullptr == hDevice`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER"]
    #[doc = "         + `nullptr == ptr`"]
    #[doc = "     - ::ZE_RESULT_ERROR_INVALID_ENUMERATION"]
    #[doc = "         + advice"]
    pub fn zeCommandListAppendMemAdvise(
        hCommandList: ze_command_list_handle_t,
        hDevice: ze_device_handle_t,
        ptr: *const ::std::os::raw::c_void,
        size: usize,
        advice: ze_memory_advice_t,
    ) -> ze_result_t;
}
